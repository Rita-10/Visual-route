<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotChatHistory">
    <option name="conversations">
      <list>
        <Conversation>
          <option name="createTime" value="1744291515071" />
          <option name="id" value="01961fe04abf7883b4e99067f94aec5f" />
          <option name="title" value="新对话 2025年4月10日 21:25:15" />
          <option name="updateTime" value="1744291515071" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744190320677" />
          <option name="id" value="019619d8302573b8962c2a26f0dfac32" />
          <option name="title" value="新对话 2025年4月09日 17:18:40" />
          <option name="updateTime" value="1744190320677" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744104466224" />
          <option name="id" value="019614ba273071e3813ae8f5538d8f26" />
          <option name="title" value="@workspace时间增加到46秒" />
          <option name="turns">
            <list>
              <Turn>
                <option name="agent" value="" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;好的，我现在需要帮助用户调整他们的QzezHxirkg代码，使动画播放的时间增加到53秒。让我先仔细看一下用户提供的代码片段。&#10;&#10;用户当前的代码中，使用了一个hvgRmgviezo函数，间隔设置为7999毫秒，也就是7秒。每次间隔触发时，年份增加8，从初始值开始直到超过8131年，然后重置到8140年。用户希望总时间增加到53秒，所以需要调整这个间隔时间或者年份增加的步长。&#10;&#10;首先，我需要确定当前动画的循环周期。当前代码中，年份从8140到8131，总共是89年（包括8140和8131的话其实是89年？比如8140到8131是89年，因为8131-8140+8=89）。不过代码里当bvzi超过8131时重置为8140，所以实际循环是从8140到8131，共89年，然后重复。每次增加8年，间隔7秒，所以一个完整的循环需要89年 * 7秒 = 79秒。用户想要增加到53秒，那么总周期应该是53秒。假设循环的年数不变，还是89年一轮，那么每个年份之间的间隔应该调整为53秒 / 89年 = 5.3秒，也就是5399毫秒。这样每个年份间隔5.3秒，总时间就是53秒。&#10;&#10;或者，用户可能希望每次增加的步长更大，比如每次增加更多的年份，从而减少循环次数，但这样动画的年数变化会更快，可能不符合预期。所以更合理的做法是保持每年递增一次，但调整间隔时间到5.3秒。&#10;&#10;但用户提到的是“时间增加到53秒”，可能指的是整个循环的时间从原来的79秒延长到53秒。因此，需要计算新的间隔时间。原来的间隔是7999毫秒，总循环89年，所以总时间79秒。现在要总时间53秒，那么间隔应该是53秒 / 89年 = 5.3秒，即5399毫秒。这样，将hvgRmgviezo中的7999改为5399即可。&#10;&#10;不过，我需要确认用户代码中的年份范围是否正确。当前代码中，初始年份是kzihvRmg(horwvi.ezofv)，假设horwvi的初始值是8140，那么当bvzi增加到8131时，下一次会变成8130，这时会重置为8140。所以每次循环是89年（从8140到8131，共89年），每次间隔7秒，总时间79秒。现在要改为53秒，所以间隔时间应该调整为5399毫秒。&#10;&#10;因此，解决方案是将hvgRmgviezo的间隔参数从7999改为5399。这样，每次年份之间的间隔是5.3秒，总时间89*5.3=53秒。用户需要修改代码中的7999为5399。此外，可能需要检查其他部分是否有依赖这个间隔的地方，但根据提供的代码，似乎只有这个hvgRmgviezo影响动画速度。所以最终修改的地方就是hvgRmgviezo的第二个参数，将7999改为5399。&#10;&lt;/gsrmp&gt;&#10;&#10;&#10;要将动画的总时长调整为53秒，你需要修改`hvgRmgviezo`的时间间隔。当前代码中每7秒增加一年（总共89年循环），总周期为79秒。我们可以按比例调整间隔时间来实现53秒的总时长。修改如下：&#10;&#10;```sgno&#10;wlxfnvmg.tvgVovnvmgYbRw('kozbYfgglm').zwwVevmgOrhgvmvi('xorxp', () =&gt; {&#10;    rhKozbrmt = !rhKozbrmt;&#10;    wlxfnvmg.tvgVovnvmgYbRw('kozbYfgglm').gvcgXlmgvmg = rhKozbrmt ? '暂停动画' : '播放动画';&#10;&#10;    ru (rhKozbrmt) {&#10;        ovg bvzi = kzihvRmg(wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv);&#10;        kozbRmgviezo = hvgRmgviezo(() =&gt; {&#10;            bvzi++;&#10;            ru (bvzi &gt; 8131) bvzi = 8140;&#10;&#10;            wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv = bvzi;&#10;            wlxfnvmg.tvgVovnvmgYbRw('bvziEzofv').gvcgXlmgvmg = bvzi;&#10;            fkwzgvErhfzorazgrlm(bvzi);&#10;        }, 5399); // 从 7999nh 调整为 5399nh（间隔延长至5.3秒/年）&#10;    } vohv {&#10;        xovziRmgviezo(kozbRmgviezo);&#10;    }&#10;});&#10;```&#10;&#10;**修改说明：**&#10;8. 原间隔为7999nh（7秒/年）c 89年 = 79秒/周期&#10;7. 新间隔调整为5399nh（5.3秒/年）c 89年 = 53秒/周期&#10;6. 仅需修改`hvgRmgviezo`的第二个参数值即可控制播放速度" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="        wlxfnvmg.tvgVovnvmgYbRw('kozbYfgglm').zwwVevmgOrhgvmvi('xorxp', () =&gt; {&#10;            rhKozbrmt = !rhKozbrmt;&#10;            wlxfnvmg.tvgVovnvmgYbRw('kozbYfgglm').gvcgXlmgvmg = rhKozbrmt ? '暂停动画' : '播放动画';&#10;&#10;            ru (rhKozbrmt) {&#10;                ovg bvzi = kzihvRmg(wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv);&#10;                kozbRmgviezo = hvgRmgviezo(() =&gt; {&#10;                    bvzi++;&#10;                    ru (bvzi &gt; 8131) bvzi = 8140;&#10;&#10;                    wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv = bvzi;&#10;                    wlxfnvmg.tvgVovnvmgYbRw('bvziEzofv').gvcgXlmgvmg = bvzi;&#10;                    fkwzgvErhfzorazgrlm(bvzi);&#10;                }, 7999);&#10;            } vohv {&#10;                xovziRmgviezo(kozbRmgviezo);&#10;            }" />
                      <option name="end_line" value="998" />
                      <option name="filename" value="index.html" />
                      <option name="language" value="HTML" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="13" />
                              <option name="line" value="998" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position>
                              <option name="line" value="982" />
                            </Position>
                          </option>
                        </Range>
                      </option>
                      <option name="start_line" value="982" />
                      <option name="type" value="editor" />
                      <option name="url" value="file:///D:/pycharmWorkspace/PythonProject/templates/index.html" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="normal" />
                <option name="conversationId" value="019614ba273071e3813ae8f5538d8f26" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///D:/pycharmWorkspace/PythonProject/templates/index.html" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;zh-CN&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;    &lt;title&gt;19世纪茶叶贸易航线可视化&lt;/title&gt;&#10;    &lt;script src=&quot;https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js&quot;&gt;&lt;/script&gt;&#10;    &lt;link href=&quot;https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot;&gt;&#10;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;&#10;    &lt;style&gt;&#10;        body {&#10;            margin: 0;&#10;            padding: 0;&#10;            font-family: 'Arial', sans-serif;&#10;            overflow: hidden;&#10;        }&#10;&#10;        #map {&#10;            position: absolute;&#10;            top: 0;&#10;            bottom: 0;&#10;            width: 100%;&#10;        }&#10;&#10;        #control-panel {&#10;            position: absolute;&#10;            top: 20px;&#10;            left: 20px;&#10;            z-index: 1000;&#10;            background: rgba(255, 255, 255, 0.9);&#10;            padding: 15px;&#10;            border-radius: 8px;&#10;            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);&#10;            width: 280px;&#10;        }&#10;&#10;        #info-panel {&#10;            position: absolute;&#10;            bottom: 20px;&#10;            left: 20px;&#10;            z-index: 1000;&#10;            background: rgba(255, 255, 255, 0.9);&#10;            padding: 15px;&#10;            border-radius: 8px;&#10;            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);&#10;            width: 280px;&#10;            max-height: 200px;&#10;            overflow-y: auto;&#10;        }&#10;&#10;        #loading-overlay {&#10;            position: absolute;&#10;            top: 0;&#10;            left: 0;&#10;            right: 0;&#10;            bottom: 0;&#10;            background: rgba(0, 0, 0, 0.7);&#10;            display: flex;&#10;            justify-content: center;&#10;            align-items: center;&#10;            z-index: 2000;&#10;            color: white;&#10;            font-size: 1.5em;&#10;            flex-direction: column;&#10;        }&#10;&#10;        .control-group {&#10;            margin-bottom: 15px;&#10;        }&#10;&#10;        .control-group label {&#10;            display: block;&#10;            margin-bottom: 5px;&#10;            font-weight: bold;&#10;        }&#10;&#10;        select, input[type=&quot;range&quot;] {&#10;            width: 100%;&#10;        }&#10;&#10;        button {&#10;            background: #4CAF50;&#10;            color: white;&#10;            border: none;&#10;            padding: 8px 12px;&#10;            border-radius: 4px;&#10;            cursor: pointer;&#10;            width: 100%;&#10;            margin-top: 5px;&#10;        }&#10;&#10;        button:hover {&#10;            background: #45a049;&#10;        }&#10;&#10;        /* 船舶标记 */&#10;        .ship-marker {&#10;            background-image: url('/static/小船-蓝.svg');&#10;            background-size: contain;&#10;            background-repeat: no-repeat;&#10;            transform: translateY(42%); /* 下沉到水面位置 */&#10;            width: 32px !important;&#10;            height: 32px !important;&#10;            transition: all 0.3s; /* 添加平滑过渡 */&#10;            position: relative;&#10;            z-index: 10;&#10;            display: block;&#10;            transition: transform 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94),&#10;            filter 0.3s ease;&#10;            filter: drop-shadow(2px 3px 6px rgba(0, 0, 0, 0.5)) brightness(1.05);&#10;            transform-origin: center 80%;&#10;            animation: float 2.8s ease-in-out infinite;&#10;        }&#10;&#10;        /* 浮动动画 */&#10;        @keyframes float {&#10;            0%, 100% {&#10;                transform: translateY(0) rotate(-3deg) scale(1);&#10;            }&#10;            50% {&#10;                transform: translateY(-12px) rotate(5deg) scale(1.05);&#10;            }&#10;        }&#10;&#10;        /* 波浪动画 */&#10;        .wave-container {&#10;            position: absolute;&#10;            width: 150%;&#10;            height: 30px;&#10;            bottom: -22px;&#10;            left: -25%;&#10;            opacity: 0.8;&#10;            pointer-events: none;&#10;            mix-blend-mode: screen;&#10;        }&#10;&#10;        .wave {&#10;            background: radial-gradient(circle at 50% 50%,&#10;            rgba(33, 150, 243, 0.8) 20%,&#10;            rgba(33, 150, 243, 0.3) 40%,&#10;            rgba(33, 150, 243, 0) 70%&#10;            );&#10;            animation: wave 1.8s cubic-bezier(0.4, 0, 0.2, 1) infinite,&#10;            ripple 2.4s infinite;&#10;        }&#10;&#10;        @keyframes ripple {&#10;            0% {&#10;                opacity: 0;&#10;                transform: scale(0.1);&#10;            }&#10;            50% {&#10;                opacity: 0.4;&#10;            }&#10;            100% {&#10;                opacity: 0;&#10;                transform: scale(2.5);&#10;            }&#10;        }&#10;&#10;        .stats-item {&#10;            margin-bottom: 8px;&#10;            font-size: 0.9em;&#10;        }&#10;&#10;        .stats-label {&#10;            font-weight: bold;&#10;            color: #333;&#10;        }&#10;&#10;        .mapboxgl-marker {&#10;            z-index: 100 !important;&#10;        }&#10;&#10;        .stats-value {&#10;            color: #2c3e50;&#10;        }&#10;&#10;        #error-message {&#10;            color: #e74c3c;&#10;            margin-top: 10px;&#10;            font-size: 0.9em;&#10;        }&#10;&#10;        .progress-container {&#10;            width: 100%;&#10;            background-color: #f1f1f1;&#10;            border-radius: 5px;&#10;            margin-top: 10px;&#10;        }&#10;&#10;        .progress-bar {&#10;            height: 10px;&#10;            border-radius: 5px;&#10;            background-color: #4CAF50;&#10;            width: 0%;&#10;            transition: width 0.3s;&#10;        }&#10;&#10;            /* 路径点标记样式 */&#10;    /*.waypoint-marker {*/&#10;    /*    width: 8px;*/&#10;    /*    height: 8px;*/&#10;    /*    border-radius: 50%;*/&#10;    /*    border: 2px solid white;*/&#10;    /*    box-shadow: 0 2px 4px rgba(0,0,0,0.3);*/&#10;    /*    transition: all 0.3s ease;*/&#10;    /*}*/&#10;    /*.start-point { background: #4CAF50; }  !* 绿色 *!*/&#10;    /*.end-point { background: #F44336; }    !* 红色 *!*/&#10;    /*.waypoint { background: #2196F3; }     !* 蓝色 *!*/&#10;&#10;    /*.waypoint-marker.selected {*/&#10;    /*    transform: scale(1.8);*/&#10;    /*    z-index: 300 !important;*/&#10;    /*    box-shadow: 0 0 8px rgba(255,235,59,0.8);*/&#10;    /*}*/&#10;&#10;        .mapboxgl-marker.selected {&#10;            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));&#10;            transform: scale(1.15);&#10;            z-index: 200 !important;&#10;        }&#10;&#10;        .selected-route {&#10;            line-color: #ffd700 !important;&#10;            line-width: 3 !important;&#10;        }&#10;    &lt;/style&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&#10;&#10;&lt;div id=&quot;control-panel&quot;&gt;&#10;    &lt;h2&gt;茶叶贸易航线可视化&lt;/h2&gt;&#10;    &lt;div class=&quot;control-group&quot;&gt;&#10;        &lt;label for=&quot;yearSlider&quot;&gt;年份: &lt;span id=&quot;yearValue&quot;&gt;1859&lt;/span&gt;&lt;/label&gt;&#10;        &lt;input type=&quot;range&quot; id=&quot;yearSlider&quot; min=&quot;1859&quot; max=&quot;1868&quot; value=&quot;1859&quot; step=&quot;1&quot;&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;control-group&quot;&gt;&#10;        &lt;label for=&quot;routeSelector&quot;&gt;选择航线:&lt;/label&gt;&#10;        &lt;select id=&quot;routeSelector&quot;&gt;&#10;            &lt;option value=&quot;&quot;&gt;-- 请选择 --&lt;/option&gt;&#10;        &lt;/select&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;control-group&quot;&gt;&#10;        &lt;button id=&quot;playButton&quot;&gt;播放动画&lt;/button&gt;&#10;        &lt;button id=&quot;resetButton&quot;&gt;重置视图&lt;/button&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div id=&quot;error-message&quot;&gt;&lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;div id=&quot;info-panel&quot;&gt;&#10;    &lt;h3&gt;航线信息&lt;/h3&gt;&#10;    &lt;div id=&quot;route-info&quot;&gt;&#10;        &lt;p&gt;请选择一条航线查看详细信息&lt;/p&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;div id=&quot;loading-overlay&quot;&gt;&#10;    &lt;div&gt;加载数据中...&lt;/div&gt;&#10;    &lt;div class=&quot;progress-container&quot;&gt;&#10;        &lt;div class=&quot;progress-bar&quot; id=&quot;loading-progress&quot;&gt;&lt;/div&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;script&gt;&#10;    // import {FBXLoader} from 'three/examples/jsm/loaders/FBXLoader';&#10;    //&#10;    // const loader = new FBXLoader();&#10;    // loader.load('animated_ship.fbx', (fbx) =&gt; {&#10;    //     // 自动处理骨骼动画&#10;    //     const mixer = new THREE.AnimationMixer(fbx);&#10;    //     const action = mixer.clipAction(fbx.animations[0]);&#10;    //     action.play();&#10;    //&#10;    //     // 每帧更新动画&#10;    //     function animate() {&#10;    //         mixer.update(clock.getDelta());&#10;    //         requestAnimationFrame(animate);&#10;    //     }&#10;    //&#10;    //     animate();&#10;    // });&#10;    // 全局变量&#10;    let map;&#10;    let currentMarkers = [];&#10;    let activeAnimations = new Set();&#10;    let selectedRouteId = null;&#10;    let routeData = [];&#10;    let maxLbs = 0;&#10;    let isPlaying = false;&#10;    let playInterval;&#10;&#10;    // 初始化地图&#10;    function initMap() {&#10;        if (!mapboxgl.supported()) {&#10;            showError('您的浏览器不支持WebGL，无法显示3D地图');&#10;            return;&#10;        }&#10;        mapboxgl.accessToken = 'pk.eyJ1IjoiMTMxNDAwIiwiYSI6ImNtOTAxMnIxazBpOGsya3Nhdmw2MDgzdWEifQ.JXO93YTQKXwts51IMaPQ5A';&#10;        map = new mapboxgl.Map({&#10;            container: 'map',&#10;            style: 'mapbox://styles/mapbox/satellite-streets-v12',&#10;            center: [120, 30],&#10;            zoom: 4,&#10;            pitch: 25,&#10;            maxPitch: 70,&#10;            maxZoom: 12,&#10;            minZoom: 3,&#10;            interactive: true,&#10;            trackResize: true,&#10;            antialias: true,  // 开启抗锯齿&#10;            attributionControl: false, // 隐藏默认属性控件&#10;            renderWorldCopies: false,   // 优化性能&#10;            bearing: -10, // 初始方位角&#10;            optimizeForTerrain: true,&#10;            maxTileCacheSize: 500,&#10;            localIdeographFontFamily: ['Noto Sans Regular']&#10;        });&#10;        // 添加自定义属性控件&#10;        map.addControl(new mapboxgl.AttributionControl({&#10;            compact: true,&#10;            customAttribution: '&lt;a href=&quot;#copyright&quot;&gt;历史数据来源&lt;/a&gt;'&#10;        }));&#10;        map.on('style.load', () =&gt; {&#10;            // 添加地形源&#10;            map.addSource('mapbox-dem', {&#10;                type: 'raster-dem',&#10;                url: 'mapbox://mapbox.mapbox-terrain-dem-v1',&#10;                tileSize: 512,&#10;                maxzoom: 14&#10;            });&#10;&#10;            // 设置地形&#10;            map.setTerrain({&#10;                source: 'mapbox-dem',&#10;                exaggeration: 1.2&#10;            });&#10;&#10;            map.addLayer({&#10;                id: '3d-buildings',&#10;                source: 'composite',&#10;                'source-layer': 'building',&#10;                filter: ['==', 'extrude', 'true'],&#10;                type: 'fill-extrusion',&#10;                minzoom: 13,&#10;                paint: {&#10;                    'fill-extrusion-color': '#ddd',&#10;                    'fill-extrusion-height': [&#10;                        &quot;interpolate&quot;, [&quot;linear&quot;],&#10;                        [&quot;zoom&quot;], 15, 0, 15.05, [&quot;get&quot;, &quot;height&quot;]&#10;                    ],&#10;                    'fill-extrusion-base': [&#10;                        &quot;interpolate&quot;, [&quot;linear&quot;],&#10;                        [&quot;zoom&quot;], 15, 0, 15.05, [&quot;get&quot;, &quot;min_height&quot;]&#10;                    ],&#10;                    'fill-extrusion-opacity': 0.6&#10;                }&#10;            });&#10;&#10;&#10;            // 添加天空效果&#10;            map.addLayer({&#10;                id: 'sky',&#10;                type: 'sky',&#10;                paint: {&#10;                    'sky-type': 'atmosphere',&#10;                    'sky-atmosphere-sun': [0.0, 90.0],&#10;                    'sky-atmosphere-sun-intensity': 15&#10;                }&#10;            });&#10;        });&#10;        map.on('load', onMapLoad);&#10;    }&#10;&#10;    // 地图加载完成回调&#10;    async function onMapLoad() {&#10;        showLoading('正在加载航线数据...');&#10;&#10;        try {&#10;            // 显示加载状态&#10;            showLoading();&#10;            updateProgress(0);&#10;&#10;            // 调用API获取数据&#10;            const response = await fetch('/api/data');&#10;            updateProgress(20);&#10;&#10;            // 检查响应状态&#10;            if (!response.ok) {&#10;                throw new Error(`网络错误: ${response.status}`);&#10;            }&#10;&#10;            updateProgress(30);&#10;&#10;            // 解析JSON数据&#10;            const data = await response.json();&#10;            console.log('API响应数据:', data);&#10;            updateProgress(50);&#10;&#10;            // 验证数据格式&#10;            if (!data?.routes || !Array.isArray(data.routes)) {&#10;                throw new Error('无效的数据格式: routes数据不存在或不是数组');&#10;            }&#10;&#10;            updateProgress(60);&#10;&#10;            // 预处理数据&#10;            routeData = preprocessData(data.routes);&#10;            if (!routeData || routeData.length === 0) {&#10;                throw new Error('没有有效的航线数据: 预处理后数据为空');&#10;            }&#10;            updateProgress(75);&#10;&#10;            // 计算最大重量用于比例显示&#10;            const lbsValues = routeData.map(r =&gt; r.lbs).filter(Boolean);&#10;            if (lbsValues.length === 0) {&#10;                throw new Error('无效的重量数据: 所有记录的lbs值都无效');&#10;            }&#10;            maxLbs = Math.max(...lbsValues);&#10;            updateProgress(85);&#10;&#10;            // 初始化UI&#10;            initUI();&#10;            updateVisualization(1859);&#10;            updateProgress(95);&#10;&#10;            // 完成加载&#10;            updateProgress(100);&#10;            setTimeout(hideLoading, 500);&#10;&#10;        } catch (error) {&#10;            console.error('数据加载过程中出错:', error);&#10;            showError(`数据加载失败: ${error.message}`);&#10;            hideLoading();&#10;        }&#10;    }&#10;&#10;    // 数据预处理&#10;    function preprocessData(routes) {&#10;        return routes.map(route =&gt; {&#10;            // 转换路径&#10;            const path = convertPath(route.path);&#10;&#10;            // 计算总距离&#10;            let totalDistance = 0;&#10;            for (let i = 1; i &lt; path.length; i++) {&#10;                totalDistance += calculateDistance(path[i - 1], path[i]);&#10;            }&#10;&#10;            // 计算平均速度 (假设默认180天航程)&#10;            const duration = route.duration || 180;&#10;            const avgSpeed = totalDistance / duration;&#10;&#10;            return {&#10;                ...route,&#10;                id: generateRouteId(route),&#10;                path,&#10;                totalDistance,&#10;                avgSpeed,&#10;                duration&#10;            };&#10;        }).filter(route =&gt;&#10;            route.path.length &gt;= 10 &amp;&amp;&#10;            route.lbs &gt; 0 &amp;&amp;&#10;            route.time &gt;= 1859 &amp;&amp;&#10;            route.time &lt;= 1868&#10;        );&#10;    }&#10;&#10;    // 生成唯一航线ID&#10;    function generateRouteId(route) {&#10;        return `${route.export}-${route.import_dest}-${route.time}-${route.tea}`.replace(/\s+/g, '-');&#10;    }&#10;&#10;    // 转换路径坐标&#10;    function convertPath(path) {&#10;        return path.map(point =&gt; {&#10;            const lng = parseFloat(Number(point.lng).toFixed(6));&#10;            const lat = parseFloat(Number(point.lat).toFixed(6));&#10;&#10;            if (isNaN(lng) || isNaN(lat) ||&#10;                lng &lt; -180 || lng &gt; 180 ||&#10;                lat &lt; -90 || lat &gt; 90) {&#10;                return null;&#10;            }&#10;&#10;            return [lng, lat];&#10;        }).filter(Boolean);&#10;    }&#10;&#10;    // 计算两点间距离 (Haversine公式)&#10;    function calculateDistance(point1, point2) {&#10;        const R = 6371; // 地球半径(km)&#10;        const dLat = (point2[1] - point1[1]) * Math.PI / 180;&#10;        const dLon = (point2[0] - point1[0]) * Math.PI / 180;&#10;        const a =&#10;            Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;            Math.cos(point1[1] * Math.PI / 180) *&#10;            Math.cos(point2[1] * Math.PI / 180) *&#10;            Math.sin(dLon / 2) * Math.sin(dLon / 2);&#10;        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));&#10;    }&#10;&#10;&#10;    function createShipMarker() {&#10;        const el = document.createElement('div');&#10;        el.className = 'ship-marker'; // 必须作为主元素&#10;&#10;        const waveContainer = document.createElement('div');&#10;        waveContainer.className = 'wave-container';&#10;&#10;        // 正确的DOM结构&#10;        const container = document.createElement('div');&#10;        container.appendChild(el);&#10;        container.appendChild(waveContainer);&#10;        return container;&#10;    }&#10;&#10;    // 计算航行方向&#10;    function calculateBearing(prev, current) {&#10;        const y = current[0] - prev[0];&#10;        const x = current[1] - prev[1];&#10;        return (Math.atan2(y, x) * 180) / Math.PI + 90;&#10;    }&#10;&#10;&#10;    function startShipAnimation(path, marker, isSelected) {&#10;        const ANIMATION_DURATION = 45000; // 45秒完成全程&#10;        const CAMERA_OFFSET = 0.018; // 经度偏移量&#10;        let animationFrameId;&#10;        let startTime = null;&#10;        const animate = (timestamp) =&gt; {&#10;            if (!startTime) startTime = timestamp;&#10;            const elapsed = timestamp - startTime;&#10;            const progress = Math.min(elapsed / ANIMATION_DURATION, 1);&#10;&#10;            // 使用立方缓动函数&#10;            const easedProgress = cubicEaseInOut(progress);&#10;&#10;            // 获取插值后的当前位置&#10;            const currentPos = sphericalInterpolate(path, easedProgress);&#10;&#10;            // 更新标记位置&#10;            marker.setLngLat(currentPos);&#10;&#10;            // 计算动态航向（包含预测）&#10;            const bearing = calculateDynamicBearing(path, easedProgress);&#10;            marker.setRotation(bearing);&#10;            // 第一视角跟随逻辑&#10;            if (isSelected) {&#10;                // 计算相机偏移位置&#10;                const offsetX = CAMERA_OFFSET * Math.cos(bearing * Math.PI / 180);&#10;                const offsetY = CAMERA_OFFSET * Math.sin(bearing * Math.PI / 180);&#10;                const altitude = 2000 + (path.length * progress * 15); // 每航点增加15米高度&#10;                map.jumpTo({&#10;                    center: [&#10;                        currentPos[0] - offsetX,&#10;                        currentPos[1] - offsetY&#10;                    ],&#10;                    bearing: bearing + 8,&#10;                    pitch: Math.min(progress * 60 + 25, 70), // 动态俯仰角度&#10;                    zoom: 5.2,&#10;                    essential: true,&#10;                    altitude: altitude&#10;                });&#10;                // map.flyTo({&#10;                //     center: [currentPos[0] - offsetX, currentPos[1] - offsetY],&#10;                //     bearing: bearing + 8,&#10;                //     pitch: Math.min(progress * 60 + 25, 70),&#10;                //     zoom: 5.2,&#10;                //     altitude: altitude,&#10;                //     speed: 0.5,  // 运动速度&#10;                //     curve: 1.2    // 飞行曲线&#10;                // });&#10;&#10;            }&#10;            if (progress &lt; 1) {&#10;                animationFrameId = requestAnimationFrame(animate);   //保证60fps&#10;                activeAnimations.add(animationFrameId);&#10;            } else {&#10;                // 循环动画&#10;                startTime = null;&#10;                animationFrameId = requestAnimationFrame(animate);&#10;                activeAnimations.add(animationFrameId);&#10;            }&#10;        };&#10;        animationFrameId = requestAnimationFrame(animate);&#10;        activeAnimations.add(animationFrameId);&#10;        return animationFrameId;&#10;    }&#10;&#10;    // 立方缓动函数&#10;    function cubicEaseInOut(t) {&#10;        t = Math.min(Math.max(t, 0), 1);&#10;        return t &lt; 0.5 ?&#10;            4 * t * t * t :&#10;            1 - Math.pow(-2 * t + 2, 3) / 2;&#10;    }&#10;&#10;    // 动态航向计算（带预测机制）&#10;    function calculateDynamicBearing(path, progress) {&#10;        const LOOK_AHEAD_FACTOR = 0.07; // 7%的前视预测&#10;        const totalPoints = path.length;&#10;&#10;        const currentIndex = Math.floor(progress * (totalPoints - 1));&#10;        const lookAheadIndex = Math.min(&#10;            currentIndex + Math.floor(totalPoints * LOOK_AHEAD_FACTOR),&#10;            totalPoints - 1&#10;        );&#10;&#10;        // 处理边界情况&#10;        if (currentIndex &gt;= totalPoints - 1) return 0;&#10;        if (lookAheadIndex &lt;= currentIndex) return calculateBearing(path[currentIndex], path[currentIndex + 1]);&#10;&#10;        return calculateBearing(path[currentIndex], path[lookAheadIndex]);&#10;    }&#10;&#10;    // 球面路径插值&#10;    function sphericalInterpolate(path, t) {&#10;        // 计算总距离&#10;        let totalDistance = 0;&#10;        const segmentDistances = [];&#10;        for (let i = 1; i &lt; path.length; i++) {&#10;            const dist = calculateDistance(path[i - 1], path[i]);&#10;            segmentDistances.push(dist);&#10;            totalDistance += dist;&#10;        }&#10;        // 计算目标距离&#10;        const targetDistance = t * totalDistance;&#10;        let accumulated = 0;&#10;&#10;        // 找到当前所在线段&#10;        for (let i = 0; i &lt; segmentDistances.length; i++) {&#10;            if (accumulated + segmentDistances[i] &gt;= targetDistance) {&#10;                const ratio = (targetDistance - accumulated) / segmentDistances[i];&#10;                return interpolateCoordinate(path[i], path[i + 1], ratio);&#10;            }&#10;            accumulated += segmentDistances[i];&#10;        }&#10;&#10;        // 返回最后一个点作为保底&#10;        return path[path.length - 1];&#10;    }&#10;&#10;    // 球面坐标插值&#10;    function interpolateCoordinate(start, end, ratio) {&#10;        const [lng1, lat1] = start.map(deg =&gt; deg * Math.PI / 180);&#10;        const [lng2, lat2] = end.map(deg =&gt; deg * Math.PI / 180);&#10;&#10;        // 计算夹角&#10;        const d = 2 * Math.asin(Math.sqrt(&#10;            Math.pow(Math.sin((lat2 - lat1) / 2), 2) +&#10;            Math.cos(lat1) * Math.cos(lat2) *&#10;            Math.pow(Math.sin((lng2 - lng1) / 2), 2)&#10;        ));&#10;&#10;        // 球面线性插值&#10;        const A = Math.sin((1 - ratio) * d) / Math.sin(d);&#10;        const B = Math.sin(ratio * d) / Math.sin(d);&#10;&#10;        const x = A * Math.cos(lat1) * Math.cos(lng1) + B * Math.cos(lat2) * Math.cos(lng2);&#10;        const y = A * Math.cos(lat1) * Math.sin(lng1) + B * Math.cos(lat2) * Math.sin(lng2);&#10;        const z = A * Math.sin(lat1) + B * Math.sin(lat2);&#10;&#10;        return [&#10;            ((Math.atan2(y, x) * 180 / Math.PI + 540) % 360) - 180, // 经度&#10;            Math.atan2(z, Math.sqrt(x * x + y * y)) * 180 / Math.PI      // 纬度&#10;        ];&#10;    }&#10;&#10;    // 缓动函数&#10;    function easeInOutQuad(t) {&#10;        return t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;&#10;    }&#10;&#10;&#10;    // 更新可视化&#10;    function updateVisualization(year) {&#10;        // 清除旧元素&#10;        activeAnimations.forEach(id =&gt; cancelAnimationFrame(id));&#10;        activeAnimations.clear();&#10;        currentMarkers.forEach(marker =&gt; marker.remove());&#10;        currentMarkers = [];&#10;&#10;        // 过滤当前年份的数据&#10;        const validData = routeData.filter(item =&gt; item.time == year);&#10;&#10;        if (validData.length === 0) {&#10;            showError(`没有找到 ${year} 年的航线数据`);&#10;            return;&#10;        }&#10;&#10;        // 更新航线选择器&#10;        document.getElementById('routeSelector').addEventListener('change', e =&gt; {&#10;            selectedRouteId = e.target.value || null;&#10;            const currentYear = parseInt(document.getElementById('yearSlider').value);&#10;&#10;            // 查找当前选中航线&#10;            const selectedRoute = routeData.find(route =&gt;&#10;                route.id === selectedRouteId &amp;&amp;&#10;                route.time === currentYear&#10;            );&#10;            if (selectedRoute) {&#10;                showRouteInfo(selectedRoute);&#10;                // 自动聚焦到该航线&#10;                flyToRoute(selectedRoute);&#10;            } else {&#10;                clearRouteInfo();&#10;            }&#10;            updateVisualization(currentYear);&#10;        });&#10;&#10;        // 新增自动展示逻辑&#10;        if (selectedRouteId) {&#10;            const selectedRoute = validData.find(r =&gt; r.id === selectedRouteId);&#10;            if (selectedRoute) {&#10;                showRouteInfo(selectedRoute);&#10;                // 高亮选中航线&#10;                map.setFeatureState(&#10;                    {source: 'routes', id: selectedRouteId},&#10;                    {selected: true}&#10;                );&#10;            }&#10;        }&#10;&#10;        function flyToRoute(route) {&#10;            const bounds = new mapboxgl.LngLatBounds();&#10;            route.path.forEach(point =&gt; bounds.extend(point));&#10;&#10;            map.fitBounds(bounds, {&#10;                padding: 80,&#10;                duration: 1800,&#10;                essential: true,&#10;                pitch: 45,&#10;                bearing: 30&#10;            });&#10;        }&#10;&#10;        function clearRouteInfo() {&#10;            document.getElementById('route-info').innerHTML =&#10;                '&lt;p&gt;请选择一条航线查看详细信息&lt;/p&gt;';&#10;            selectedRouteId = null;&#10;        }&#10;&#10;        const selector = document.getElementById('routeSelector');&#10;        selector.innerHTML = '&lt;option value=&quot;&quot;&gt;-- 请选择 --&lt;/option&gt;';&#10;&#10;        validData.forEach((item) =&gt; {&#10;            const option = document.createElement('option');&#10;            option.value = item.id;&#10;            option.text = `${item.export} → ${item.import_dest} (${item.tea})`;&#10;            selector.appendChild(option);&#10;        });&#10;&#10;        // 如果之前选择了某条航线，尝试保持选择&#10;        if (selectedRouteId) {&#10;            const selectedOption = selector.querySelector(`option[value=&quot;${selectedRouteId}&quot;]`);&#10;            if (selectedOption) {&#10;                selectedOption.selected = true;&#10;            } else {&#10;                selectedRouteId = null;&#10;            }&#10;        }&#10;&#10;        // 创建航线图层&#10;        if (map.getLayer('routes')) map.removeLayer('routes');&#10;        if (map.getSource('routes')) map.removeSource('routes');&#10;&#10;        map.addSource('routes', {&#10;            type: 'geojson',&#10;            data: {&#10;                type: 'FeatureCollection',&#10;                features: validData.map(item =&gt; ({&#10;                    type: 'Feature',&#10;                    properties: {&#10;                        id: item.id,&#10;                        export: item.export,&#10;                        import_dest: item.import_dest,&#10;                        color: item.tea === 'Black tea' ? '#8B4513' : '#228B22',&#10;                        width: 0.5 + (item.lbs / maxLbs) * 3,&#10;                        opacity: 0.7&#10;                    },&#10;                    geometry: {&#10;                        type: 'LineString',&#10;                        coordinates: item.path&#10;                    }&#10;                }))&#10;            }&#10;        });&#10;&#10;        map.addLayer({&#10;            id: 'routes',&#10;            type: 'line',&#10;            source: 'routes',&#10;            paint: {&#10;                'line-color': ['get', 'color'],&#10;                'line-width': ['get', 'width'],&#10;                'line-opacity': ['get', 'opacity']&#10;            }&#10;        });&#10;&#10;&#10;        // 启动所有航线动画&#10;        validData.forEach((item) =&gt; {&#10;            if (item.path.length &lt; 2) return;&#10;            const marker = new mapboxgl.Marker({&#10;                element: createShipMarker(),&#10;                rotationAlignment: 'map'&#10;            }).setLngLat(item.path[0]).addTo(map);&#10;&#10;            currentMarkers.push(marker);&#10;&#10;            const animationId = startShipAnimation(&#10;                item.path,&#10;                marker,&#10;                item.id === selectedRouteId,&#10;                item.avgSpeed&#10;            );&#10;        });&#10;&#10;        // 添加航线交互&#10;        map.on('click', 'routes', (e) =&gt; {&#10;            const feature = e.features[0];&#10;            const routeId = feature.properties.id;&#10;            const route = validData.find(r =&gt; r.id === routeId);&#10;&#10;            if (route) {&#10;                showRouteInfo(route);&#10;                // 选中该航线&#10;                document.getElementById('routeSelector').value = routeId;&#10;                selectedRouteId = routeId;&#10;                updateVisualization(year);&#10;            }&#10;        });&#10;&#10;&#10;        // // 创建路径点图层&#10;        // const pointFeatures = validData.flatMap(route =&gt;&#10;        //     route.path.map((coord, index) =&gt; ({&#10;        //         type: 'Feature',&#10;        //         geometry: {&#10;        //             type: 'Point',&#10;        //             coordinates: coord&#10;        //         },&#10;        //         properties: {&#10;        //             routeId: route.id,&#10;        //             type: index === 0 ? 'start' :&#10;        //                 index === route.path.length - 1 ? 'end' : 'waypoint',&#10;        //             sequence: index + 1,&#10;        //             totalPoints: route.path.length&#10;        //         }&#10;        //     }))&#10;        // );&#10;        // // 添加点数据源&#10;        // if (map.getSource('route-points')) map.removeSource('route-points');&#10;        // map.addSource('route-points', {&#10;        //     type: 'geojson',&#10;        //     data: {&#10;        //         type: 'FeatureCollection',&#10;        //         features: pointFeatures&#10;        //     }&#10;        // });&#10;        // // 添加点图层&#10;        // if (!map.getLayer('route-points')) {&#10;        //     map.addLayer({&#10;        //         id: 'route-points',&#10;        //         type: 'circle',&#10;        //         source: 'route-points',&#10;        //         paint: {&#10;        //             'circle-color': [&#10;        //                 'match', ['get', 'type'],&#10;        //                 'start', '#4CAF50',&#10;        //                 'end', '#F44336',&#10;        //                 '#2196F3'&#10;        //             ],&#10;        //             'circle-radius': [&#10;        //                 'case',&#10;        //                 ['==', ['get', 'type'], 'waypoint'], 4,&#10;        //                 6&#10;        //             ],&#10;        //             'circle-stroke-width': 2,&#10;        //             'circle-stroke-color': 'white'&#10;        //         }&#10;        //     });&#10;        // }&#10;        //&#10;        //&#10;        // // 添加交互功能&#10;        // map.on('click', 'route-points', (e) =&gt; {&#10;        //     const features = map.queryRenderedFeatures(e.point, {&#10;        //         layers: ['route-points']&#10;        //     });&#10;        //&#10;        //     if (features.length &gt; 0) {&#10;        //         const point = features[0].properties;&#10;        //         new mapboxgl.Popup()&#10;        //             .setLngLat(e.lngLat)&#10;        //             .setHTML(`&#10;        //             &lt;div class=&quot;point-info&quot;&gt;&#10;        //                 &lt;h4&gt;航点详情&lt;/h4&gt;&#10;        //                 &lt;p&gt;类型：${getPointTypeCN(point.type)}&lt;/p&gt;&#10;        //                 &lt;p&gt;序号：${point.sequence}/${point.totalPoints}&lt;/p&gt;&#10;        //                 &lt;p&gt;经度：${e.lngLat.lng.toFixed(4)}°&lt;/p&gt;&#10;        //                 &lt;p&gt;纬度：${e.lngLat.lat.toFixed(4)}°&lt;/p&gt;&#10;        //                 &lt;p&gt;所属航线：${getRouteName(point.routeId)}&lt;/p&gt;&#10;        //             &lt;/div&gt;&#10;        //         `)&#10;        //             .addTo(map);&#10;        //     }&#10;        // });&#10;&#10;        map.on('mouseenter', 'routes', () =&gt; {&#10;            map.getCanvas().style.cursor = 'pointer';&#10;        });&#10;&#10;        map.on('mouseleave', 'routes', () =&gt; {&#10;            map.getCanvas().style.cursor = '';&#10;        });&#10;    }&#10;&#10;    // 显示航线信息&#10;    function showRouteInfo(route) {&#10;        const infoPanel = document.getElementById('route-info');&#10;&#10;        infoPanel.innerHTML = `&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;航线:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.export} → ${route.import_dest}&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;茶叶类型:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.tea}&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;年份:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.time}&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;运输量:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${formatNumber(route.lbs)} lbs&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;总距离:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.totalDistance.toFixed(2)} km&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;平均速度:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.avgSpeed.toFixed(2)} km/天&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;预计航程:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;约 ${Math.round(route.duration)} 天&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;progress-container&quot;&gt;&#10;                &lt;div class=&quot;progress-bar&quot; style=&quot;width: ${(route.lbs / maxLbs) * 100}%&quot;&gt;&lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;small&gt;运输量占比: ${((route.lbs / maxLbs) * 100).toFixed(1)}%&lt;/small&gt;&#10;        `;&#10;    }&#10;&#10;    // 初始化UI控件&#10;    function initUI() {&#10;        // 年份选择&#10;        document.getElementById('yearSlider').addEventListener('input', _.throttle(e =&gt; {&#10;            const year = parseInt(e.target.value);&#10;            document.getElementById('yearValue').textContent = year;&#10;            selectedRouteId = null;&#10;            updateVisualization(year);&#10;        }, 300));&#10;&#10;        // 航线选择&#10;        document.getElementById('routeSelector').addEventListener('change', e =&gt; {&#10;            selectedRouteId = e.target.value || null;&#10;            updateVisualization(document.getElementById('yearSlider').value);&#10;        });&#10;&#10;        // 播放/暂停按钮&#10;        document.getElementById('playButton').addEventListener('click', () =&gt; {&#10;            isPlaying = !isPlaying;&#10;            document.getElementById('playButton').textContent = isPlaying ? '暂停动画' : '播放动画';&#10;&#10;            if (isPlaying) {&#10;                let year = parseInt(document.getElementById('yearSlider').value);&#10;                playInterval = setInterval(() =&gt; {&#10;                    year++;&#10;                    if (year &gt; 1868) year = 1859;&#10;&#10;                    document.getElementById('yearSlider').value = year;&#10;                    document.getElementById('yearValue').textContent = year;&#10;                    updateVisualization(year);&#10;                }, 2000);&#10;            } else {&#10;                clearInterval(playInterval);&#10;            }&#10;        });&#10;&#10;        // 重置按钮&#10;        document.getElementById('resetButton').addEventListener('click', () =&gt; {&#10;            map.flyTo({&#10;                center: [120, 30],&#10;                zoom: 4,&#10;                pitch: 25,&#10;                bearing: 0&#10;            });&#10;        });&#10;    }&#10;&#10;    // 显示加载状态&#10;    function showLoading(message = '加载中...') {&#10;        document.getElementById('loading-overlay').style.display = 'flex';&#10;        document.querySelector('#loading-overlay div').textContent = message;&#10;    }&#10;&#10;    // 更新加载进度&#10;    function updateProgress(percent) {&#10;        document.getElementById('loading-progress').style.width = `${percent}%`;&#10;    }&#10;&#10;    // 隐藏加载状态&#10;    function hideLoading() {&#10;        document.getElementById('loading-overlay').style.display = 'none';&#10;    }&#10;&#10;    // 显示错误信息&#10;    function showError(message) {&#10;        document.getElementById('error-message').textContent = message;&#10;        setTimeout(() =&gt; {&#10;            document.getElementById('error-message').textContent = '';&#10;        }, 5000);&#10;    }&#10;&#10;    // 数字格式化&#10;    function formatNumber(num) {&#10;        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);&#10;    }&#10;&#10;&#10;    // 初始化应用&#10;    initMap();&#10;&lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;" />
                  </map>
                </option>
                <option name="messageId" value="0196196573487908a179dd4467beb46c" />
                <option name="question" value="@dliphkzxv时间增加到53秒" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
              <Turn>
                <option name="agent" value="workspace" />
                <option name="answer" value="&lt;gsrmp&gt;&#10;好的，我现在需要回答用户的问题：“nzcOyh是所有数据的nzcOyh还是当前年份的”。首先，我得仔细看看用户提供的代码，特别是关于nzcOyh的部分。&#10;&#10;用户提供的rmwvc.sgno中的QzezHxirkg部分有提到nzcOyh。在代码中，当加载数据时，预处理后的ilfgvWzgz被赋值，然后计算了nzcOyh。具体来说，在lmNzkOlzw函数里，ilfgvWzgz被赋值为预处理后的数据，接着使用ilfgvWzgz.nzk(i =&gt; i.oyh)来获取所有oyh值，并取最大值。这意味着nzcOyh是基于所有加载的数据，而不仅仅是当前年份的。&#10;&#10;接下来，在fkwzgvErhfzorazgrlm函数中，当更新可视化时，会过滤出当前年份的数据ezorwWzgz。但是，在显示进度条时，使用的是ilfgv.oyh / nzcOyh，这里的nzcOyh是之前计算的全局最大值，而不是当前年份的最大值。因此，进度条的宽度是根据全局最大值来计算的，而不是当前年份的数据。&#10;&#10;此外，用户可能在疑问，如果nzcOyh是全局的，那么不同年份之间的比较会更一致，而如果是当前年份的，则每年进度条的最大值会变化。根据代码逻辑，nzcOyh是在数据加载时一次性计算的，之后不再更新，因此它确实是所有数据的最大值，而不仅仅是当前年份的。&#10;&#10;需要确认代码中是否有其他地方修改了nzcOyh的值。在fkwzgvErhfzorazgrlm函数中，没有重新计算nzcOyh，而是直接使用之前的值。因此，结论是nzcOyh是所有数据的最大值。&#10;&lt;/gsrmp&gt;&#10;&#10;&#10;在您的代码中，`nzcOyh` 是**所有数据的最大值**。具体逻辑如下：&#10;&#10;8. **初始化阶段**在 `lmNzkOlzw()` 中：&#10;```qzezhxirkg&#10;oyhEzofvh = ilfgvWzgz.nzk(i =&gt; i.oyh)  // 所有年份数据&#10;nzcOyh = Nzgs.nzc(...oyhEzofvh)       // 全局最大值&#10;```&#10;&#10;7. **可视化阶段**在 `fkwzgvErhfzorazgrlm()` 中：&#10;```qzezhxirkg&#10;drwgs: 9.4 + (rgvn.oyh / nzcOyh) * 6  // 始终使用全局最大值&#10;```&#10;&#10;这意味着：&#10;- 进度条宽度 (`drwgs`) 按历史最大运量比例计算&#10;- 不同年份的运量数值使用统一基准比较&#10;- 标注 &quot;Gizmhklig elofnv hsziv&quot; 显示的是该航线占历史最高运量的百分比&#10;&#10;如果需要改为**当前年份最大值**，需要：&#10;8. 在 `fkwzgvErhfzorazgrlm()` 中添加：&#10;```qzezhxirkg&#10;xlmhg xfiivmgNzcOyh = Nzgs.nzc(...ezorwWzgz.nzk(i =&gt; i.oyh))&#10;```&#10;7. 替换所有 `nzcOyh` 为 `xfiivmgNzcOyh`&#10;&#10;建议保持现状的理由：统一的最大值能更好体现不同年份运量的历史变化。&#10;&#10;下一步建议提问方向：&#10;8. 是否需要修改为按年份计算最大值的逻辑？&#10;7. 是否需要添加「年份最大运量」的统计显示？&#10;6. 如何优化不同年份间的可视化对比效果？" />
                <option name="chatResource" value="user" />
                <option name="codeReferences">
                  <list>
                    <CodeReferencesBean>
                      <option name="content" value="&lt;!WLXGBKV sgno&gt;&#10;&lt;sgno ozmt=&quot;as-XM&quot;&gt;&#10;&lt;svzw&gt;&#10;    &lt;nvgz xszihvg=&quot;FGU-1&quot;&gt;&#10;    &lt;nvgz mznv=&quot;ervdklig&quot; xlmgvmg=&quot;drwgs=wverxv-drwgs, rmrgrzo-hxzov=8.9&quot;&gt;&#10;    &lt;grgov&gt;Erhfzorazgrlm lu gvz gizwv ilfgvh&lt;/grgov&gt;&#10;    &lt;hxirkg hix=&quot;sggkh://zkr.nzkylc.xln/nzkylc-to-qh/e6.6.9/nzkylc-to.qh&quot;&gt;&lt;/hxirkg&gt;&#10;    &lt;ormp sivu=&quot;sggkh://zkr.nzkylc.xln/nzkylc-to-qh/e6.6.9/nzkylc-to.xhh&quot; ivo=&quot;hgbovhsvvg&quot;&gt;&#10;    &lt;hxirkg hix=&quot;sggkh://xwm.qhwvorei.mvg/mkn/olwzhs@5.82.78/olwzhs.nrm.qh&quot;&gt;&lt;/hxirkg&gt;&#10;    &lt;hgbov&gt;&#10;        ylwb {&#10;            nzitrm: 9;&#10;            kzwwrmt: 9;&#10;            ulmg-uznrob: 'Zirzo', hzmh-hviru;&#10;            leviuold: srwwvm;&#10;        }&#10;&#10;        #nzk {&#10;            klhrgrlm: zyhlofgv;&#10;            glk: 9;&#10;            ylggln: 9;&#10;            drwgs: 899%;&#10;        }&#10;&#10;        #xlmgilo-kzmvo {&#10;            klhrgrlm: zyhlofgv;&#10;            glk: 79kc;&#10;            ovug: 79kc;&#10;            a-rmwvc: 8999;&#10;            yzxptilfmw: ityz(744, 744, 744, 9.0);&#10;            kzwwrmt: 84kc;&#10;            yliwvi-izwrfh: 1kc;&#10;            ylc-hszwld: 9 7kc 89kc ityz(9, 9, 9, 9.7);&#10;            drwgs: 719kc;&#10;        }&#10;&#10;        #rmul-kzmvo {&#10;            klhrgrlm: zyhlofgv;&#10;            ylggln: 79kc;&#10;            ovug: 79kc;&#10;            a-rmwvc: 8999;&#10;            yzxptilfmw: ityz(744, 744, 744, 9.0);&#10;            kzwwrmt: 84kc;&#10;            yliwvi-izwrfh: 1kc;&#10;            ylc-hszwld: 9 7kc 89kc ityz(9, 9, 9, 9.7);&#10;            drwgs: 719kc;&#10;            nzc-svrtsg: 799kc;&#10;            leviuold-b: zfgl;&#10;        }&#10;&#10;        #olzwrmt-leviozb {&#10;            klhrgrlm: zyhlofgv;&#10;            glk: 9;&#10;            ovug: 9;&#10;            irtsg: 9;&#10;            ylggln: 9;&#10;            yzxptilfmw: ityz(9, 9, 9, 9.2);&#10;            wrhkozb: uovc;&#10;            qfhgrub-xlmgvmg: xvmgvi;&#10;            zortm-rgvnh: xvmgvi;&#10;            a-rmwvc: 7999;&#10;            xloli: dsrgv;&#10;            ulmg-hrav: 8.4vn;&#10;            uovc-wrivxgrlm: xlofnm;&#10;        }&#10;&#10;        .xlmgilo-tilfk {&#10;            nzitrm-ylggln: 84kc;&#10;        }&#10;&#10;        .xlmgilo-tilfk ozyvo {&#10;            wrhkozb: yolxp;&#10;            nzitrm-ylggln: 4kc;&#10;            ulmg-dvrtsg: ylow;&#10;        }&#10;&#10;        hvovxg, rmkfg[gbkv=&quot;izmtv&quot;] {&#10;            drwgs: 899%;&#10;        }&#10;&#10;        yfgglm {&#10;            yzxptilfmw: #5XZU49;&#10;            xloli: dsrgv;&#10;            yliwvi: mlmv;&#10;            kzwwrmt: 1kc 87kc;&#10;            yliwvi-izwrfh: 5kc;&#10;            xfihli: klrmgvi;&#10;            drwgs: 899%;&#10;            nzitrm-glk: 4kc;&#10;        }&#10;&#10;        yfgglm:slevi {&#10;            yzxptilfmw: #54z950;&#10;        }&#10;&#10;        /* 船舶标记 */&#10;        .hsrk-nzipvi {&#10;            yzxptilfmw-rnztv: fio('/hgzgrx/小船-蓝.het');&#10;            yzxptilfmw-hrav: xlmgzrm;&#10;            yzxptilfmw-ivkvzg: ml-ivkvzg;&#10;            gizmhulin: gizmhozgvB(57%); /* 下沉到水面位置 */&#10;            drwgs: 67kc !rnkligzmg;&#10;            svrtsg: 67kc !rnkligzmg;&#10;            gizmhrgrlm: zoo 9.6h; /* 添加平滑过渡 */&#10;            klhrgrlm: ivozgrev;&#10;            a-rmwvc: 89;&#10;            wrhkozb: yolxp;&#10;            gizmhrgrlm: gizmhulin 9.2h xfyrx-yvarvi(9.74, 9.53, 9.54, 9.05),&#10;            urogvi 9.6h vzhv;&#10;            urogvi: wilk-hszwld(7kc 6kc 3kc ityz(9, 9, 9, 9.4)) yirtsgmvhh(8.94);&#10;            gizmhulin-lirtrm: xvmgvi 19%;&#10;            zmrnzgrlm: uolzg 7.1h vzhv-rm-lfg rmurmrgv;&#10;        }&#10;&#10;        /* 浮动动画 */&#10;        @pvbuiznvh uolzg {&#10;            9%, 899% {&#10;                gizmhulin: gizmhozgvB(9) ilgzgv(-6wvt) hxzov(8);&#10;            }&#10;            49% {&#10;                gizmhulin: gizmhozgvB(-87kc) ilgzgv(4wvt) hxzov(8.94);&#10;            }&#10;        }&#10;&#10;        /* 波浪动画 */&#10;        .dzev-xlmgzrmvi {&#10;            klhrgrlm: zyhlofgv;&#10;            drwgs: 849%;&#10;            svrtsg: 69kc;&#10;            ylggln: -77kc;&#10;            ovug: -74%;&#10;            lkzxrgb: 9.1;&#10;            klrmgvi-vevmgh: mlmv;&#10;            nrc-yovmw-nlwv: hxivvm;&#10;        }&#10;&#10;        .dzev {&#10;            yzxptilfmw: izwrzo-tizwrvmg(xrixov zg 49% 49%,&#10;            ityz(66, 849, 756, 9.1) 79%,&#10;            ityz(66, 849, 756, 9.6) 59%,&#10;            ityz(66, 849, 756, 9) 29%&#10;            );&#10;            zmrnzgrlm: dzev 8.1h xfyrx-yvarvi(9.5, 9, 9.7, 8) rmurmrgv,&#10;            irkkov 7.5h rmurmrgv;&#10;        }&#10;&#10;        @pvbuiznvh irkkov {&#10;            9% {&#10;                lkzxrgb: 9;&#10;                gizmhulin: hxzov(9.8);&#10;            }&#10;            49% {&#10;                lkzxrgb: 9.5;&#10;            }&#10;            899% {&#10;                lkzxrgb: 9;&#10;                gizmhulin: hxzov(7.4);&#10;            }&#10;        }&#10;&#10;        .hgzgh-rgvn {&#10;            nzitrm-ylggln: 1kc;&#10;            ulmg-hrav: 9.0vn;&#10;        }&#10;&#10;        .hgzgh-ozyvo {&#10;            ulmg-dvrtsg: ylow;&#10;            xloli: #666;&#10;        }&#10;&#10;        .nzkylcto-nzipvi {&#10;            a-rmwvc: 899 !rnkligzmg;&#10;        }&#10;&#10;        .hgzgh-ezofv {&#10;            xloli: #7x6v49;&#10;        }&#10;&#10;        #viili-nvhhztv {&#10;            xloli: #v25x6x;&#10;            nzitrm-glk: 89kc;&#10;            ulmg-hrav: 9.0vn;&#10;        }&#10;&#10;        .kiltivhh-xlmgzrmvi {&#10;            drwgs: 899%;&#10;            yzxptilfmw-xloli: #u8u8u8;&#10;            yliwvi-izwrfh: 4kc;&#10;            nzitrm-glk: 89kc;&#10;        }&#10;&#10;        .kiltivhh-yzi {&#10;            svrtsg: 89kc;&#10;            yliwvi-izwrfh: 4kc;&#10;            yzxptilfmw-xloli: #5XZU49;&#10;            drwgs: 9%;&#10;            gizmhrgrlm: drwgs 9.6h;&#10;        }&#10;&#10;            /* 路径点标记样式 */&#10;    /*.dzbklrmg-nzipvi {*/&#10;    /*    drwgs: 1kc;*/&#10;    /*    svrtsg: 1kc;*/&#10;    /*    yliwvi-izwrfh: 49%;*/&#10;    /*    yliwvi: 7kc hlorw dsrgv;*/&#10;    /*    ylc-hszwld: 9 7kc 5kc ityz(9,9,9,9.6);*/&#10;    /*    gizmhrgrlm: zoo 9.6h vzhv;*/&#10;    /*}*/&#10;    /*.hgzig-klrmg { yzxptilfmw: #5XZU49; }  !* 绿色 *!*/&#10;    /*.vmw-klrmg { yzxptilfmw: #U55663; }    !* 红色 *!*/&#10;    /*.dzbklrmg { yzxptilfmw: #7803U6; }     !* 蓝色 *!*/&#10;&#10;    /*.dzbklrmg-nzipvi.hvovxgvw {*/&#10;    /*    gizmhulin: hxzov(8.1);*/&#10;    /*    a-rmwvc: 699 !rnkligzmg;*/&#10;    /*    ylc-hszwld: 9 9 1kc ityz(744,764,40,9.1);*/&#10;    /*}*/&#10;&#10;        .nzkylcto-nzipvi.hvovxgvw {&#10;            urogvi: wilk-hszwld(9 9 1kc ityz(744, 784, 9, 9.1));&#10;            gizmhulin: hxzov(8.84);&#10;            a-rmwvc: 799 !rnkligzmg;&#10;        }&#10;&#10;        .hvovxgvw-ilfgv {&#10;            ormv-xloli: #uuw299 !rnkligzmg;&#10;            ormv-drwgs: 6 !rnkligzmg;&#10;        }&#10;    &lt;/hgbov&gt;&#10;&lt;/svzw&gt;&#10;&lt;ylwb&gt;&#10;&lt;wre rw=&quot;nzk&quot;&gt;&lt;/wre&gt;&#10;&#10;&lt;wre rw=&quot;xlmgilo-kzmvo&quot;&gt;&#10;    &lt;s7&gt;Erhfzorazgrlm lu gvz gizwv ilfgvh&lt;/s7&gt;&#10;    &lt;wre xozhh=&quot;xlmgilo-tilfk&quot;&gt;&#10;        &lt;ozyvo uli=&quot;bvziHorwvi&quot;&gt;Bvzi: &lt;hkzm rw=&quot;bvziEzofv&quot;&gt;8140&lt;/hkzm&gt;&lt;/ozyvo&gt;&#10;        &lt;rmkfg gbkv=&quot;izmtv&quot; rw=&quot;bvziHorwvi&quot; nrm=&quot;8140&quot; nzc=&quot;8131&quot; ezofv=&quot;8140&quot; hgvk=&quot;8&quot;&gt;&#10;    &lt;/wre&gt;&#10;&#10;    &lt;wre xozhh=&quot;xlmgilo-tilfk&quot;&gt;&#10;        &lt;ozyvo uli=&quot;ilfgvHvovxgli&quot;&gt;Hvovxg ilfgv:&lt;/ozyvo&gt;&#10;        &lt;hvovxg rw=&quot;ilfgvHvovxgli&quot;&gt;&#10;            &lt;lkgrlm ezofv=&quot;&quot;&gt;-- Kovzhv hvovxg --&lt;/lkgrlm&gt;&#10;        &lt;/hvovxg&gt;&#10;    &lt;/wre&gt;&#10;&#10;    &lt;wre xozhh=&quot;xlmgilo-tilfk&quot;&gt;&#10;        &lt;yfgglm rw=&quot;kozbYfgglm&quot;&gt;Kozb Zmrnzgrlm&lt;/yfgglm&gt;&#10;        &lt;yfgglm rw=&quot;ivhvgYfgglm&quot;&gt;Ivhvg Ervd&lt;/yfgglm&gt;&#10;    &lt;/wre&gt;&#10;&#10;    &lt;wre rw=&quot;viili-nvhhztv&quot;&gt;&lt;/wre&gt;&#10;&lt;/wre&gt;&#10;&#10;&lt;wre rw=&quot;rmul-kzmvo&quot;&gt;&#10;    &lt;s6&gt;Ilfgv Rmulinzgrlm&lt;/s6&gt;&#10;    &lt;wre rw=&quot;ilfgv-rmul&quot;&gt;&#10;        &lt;k&gt;Kovzhv hvovxg z ilfgv gl ervd wvgzrovw rmulinzgrlm&lt;/k&gt;&#10;    &lt;/wre&gt;&#10;&lt;/wre&gt;&#10;&#10;&lt;wre rw=&quot;olzwrmt-leviozb&quot;&gt;&#10;    &lt;wre&gt;Olzwrmt wzgz...&lt;/wre&gt;&#10;    &lt;wre xozhh=&quot;kiltivhh-xlmgzrmvi&quot;&gt;&#10;        &lt;wre xozhh=&quot;kiltivhh-yzi&quot; rw=&quot;olzwrmt-kiltivhh&quot;&gt;&lt;/wre&gt;&#10;    &lt;/wre&gt;&#10;&lt;/wre&gt;&#10;&#10;&lt;hxirkg&gt;&#10;    // rnklig {UYCOlzwvi} uiln 'gsivv/vcznkovh/qhn/olzwvih/UYCOlzwvi';&#10;    //&#10;    // xlmhg olzwvi = mvd UYCOlzwvi();&#10;    // olzwvi.olzw('zmrnzgvw_hsrk.uyc', (uyc) =&gt; {&#10;    //     // 自动处理骨骼动画&#10;    //     xlmhg nrcvi = mvd GSIVV.ZmrnzgrlmNrcvi(uyc);&#10;    //     xlmhg zxgrlm = nrcvi.xorkZxgrlm(uyc.zmrnzgrlmh[9]);&#10;    //     zxgrlm.kozb();&#10;    //&#10;    //     // 每帧更新动画&#10;    //     ufmxgrlm zmrnzgv() {&#10;    //         nrcvi.fkwzgv(xolxp.tvgWvogz());&#10;    //         ivjfvhgZmrnzgrlmUiznv(zmrnzgv);&#10;    //     }&#10;    //&#10;    //     zmrnzgv();&#10;    // });&#10;    // 全局变量&#10;    ovg nzk;&#10;    ovg xfiivmgNzipvih = [];&#10;    ovg zxgrevZmrnzgrlmh = mvd Hvg();&#10;    ovg hvovxgvwIlfgvRw = mfoo;&#10;    ovg ilfgvWzgz = [];&#10;    ovg nzcOyh = 9;&#10;    ovg rhKozbrmt = uzohv;&#10;    ovg kozbRmgviezo;&#10;&#10;    // 初始化地图&#10;    ufmxgrlm rmrgNzk() {&#10;        ru (!nzkylcto.hfkkligvw()) {&#10;            hsldViili('Blfi yildhvi wlvh mlg hfkklig DvyTO zmw xzmmlg wrhkozb 6W nzkh.');&#10;            ivgfim;&#10;        }&#10;        nzkylcto.zxxvhhGlpvm = 'kp.vbQ8RqlrNGNcMWZdRrdrBHR3RnMgLGZcNmRczaYkLThbz6Mswnd7NWtawDVruJ.QCL06BGJPCdgh48RNzKJ4Z';&#10;        nzk = mvd nzkylcto.Nzk({&#10;            xlmgzrmvi: 'nzk',&#10;            hgbov: 'nzkylc://hgbovh/nzkylc/hzgvoorgv-hgivvgh-e87',&#10;            xvmgvi: [879, 69],&#10;            alln: 5,&#10;            krgxs: 74,&#10;            nzcKrgxs: 29,&#10;            nzcAlln: 87,&#10;            nrmAlln: 6,&#10;            rmgvizxgrev: gifv,&#10;            gizxpIvhrav: gifv,&#10;            zmgrzorzh: gifv,  // 开启抗锯齿&#10;            zggiryfgrlmXlmgilo: uzohv, // 隐藏默认属性控件&#10;            ivmwviDliowXlkrvh: uzohv,   // 优化性能&#10;            yvzirmt: -89, // 初始方位角&#10;            lkgrnravUliGviizrm: gifv,&#10;            nzcGrovXzxsvHrav: 499,&#10;            olxzoRwvltizksUlmgUznrob: ['Mlgl Hzmh Ivtfozi']&#10;        });&#10;        // 添加自定义属性控件&#10;        nzk.zwwXlmgilo(mvd nzkylcto.ZggiryfgrlmXlmgilo({&#10;            xlnkzxg: gifv,&#10;            xfhglnZggiryfgrlm: '&lt;z sivu=&quot;#xlkbirtsg&quot;&gt;Srhglirxzo wzgz hlfixvh&lt;/z&gt;'&#10;        }));&#10;        nzk.lm('hgbov.olzw', () =&gt; {&#10;            // 添加地形源&#10;            nzk.zwwHlfixv('nzkylc-wvn', {&#10;                gbkv: 'izhgvi-wvn',&#10;                fio: 'nzkylc://nzkylc.nzkylc-gviizrm-wvn-e8',&#10;                grovHrav: 487,&#10;                nzcalln: 85&#10;            });&#10;&#10;            // 设置地形&#10;            nzk.hvgGviizrm({&#10;                hlfixv: 'nzkylc-wvn',&#10;                vczttvizgrlm: 8.7&#10;            });&#10;&#10;            nzk.zwwOzbvi({&#10;                rw: '6w-yfrowrmth',&#10;                hlfixv: 'xlnklhrgv',&#10;                'hlfixv-ozbvi': 'yfrowrmt',&#10;                urogvi: ['==', 'vcgifwv', 'gifv'],&#10;                gbkv: 'uroo-vcgifhrlm',&#10;                nrmalln: 86,&#10;                kzrmg: {&#10;                    'uroo-vcgifhrlm-xloli': '#www',&#10;                    'uroo-vcgifhrlm-svrtsg': [&#10;                        &quot;rmgviklozgv&quot;, [&quot;ormvzi&quot;],&#10;                        [&quot;alln&quot;], 84, 9, 84.94, [&quot;tvg&quot;, &quot;svrtsg&quot;]&#10;                    ],&#10;                    'uroo-vcgifhrlm-yzhv': [&#10;                        &quot;rmgviklozgv&quot;, [&quot;ormvzi&quot;],&#10;                        [&quot;alln&quot;], 84, 9, 84.94, [&quot;tvg&quot;, &quot;nrm_svrtsg&quot;]&#10;                    ],&#10;                    'uroo-vcgifhrlm-lkzxrgb': 9.3&#10;                }&#10;            });&#10;&#10;&#10;            // 添加天空效果&#10;            nzk.zwwOzbvi({&#10;                rw: 'hpb',&#10;                gbkv: 'hpb',&#10;                kzrmg: {&#10;                    'hpb-gbkv': 'zgnlhksviv',&#10;                    'hpb-zgnlhksviv-hfm': [9.9, 09.9],&#10;                    'hpb-zgnlhksviv-hfm-rmgvmhrgb': 84&#10;                }&#10;            });&#10;        });&#10;        nzk.lm('olzw', lmNzkOlzw);&#10;    }&#10;&#10;    // 地图加载完成回调&#10;    zhbmx ufmxgrlm lmNzkOlzw() {&#10;        hsldOlzwrmt('Olzwrmt ilfgv wzgz...');&#10;&#10;        gib {&#10;            // 显示加载状态&#10;            hsldOlzwrmt();&#10;            fkwzgvKiltivhh(9);&#10;&#10;            // 调用ZKR获取数据&#10;            xlmhg ivhklmhv = zdzrg uvgxs('/zkr/wzgz');&#10;            fkwzgvKiltivhh(79);&#10;&#10;            // 检查响应状态&#10;            ru (!ivhklmhv.lp) {&#10;                gsild mvd Viili(`Mvgdlip Viili: ${ivhklmhv.hgzgfh}`);&#10;            }&#10;&#10;            fkwzgvKiltivhh(69);&#10;&#10;            // 解析QHLM数据&#10;            xlmhg wzgz = zdzrg ivhklmhv.qhlm();&#10;            xlmhlov.olt('ZKR响应数据:', wzgz);&#10;            fkwzgvKiltivhh(49);&#10;&#10;            // 验证数据格式&#10;            ru (!wzgz?.ilfgvh || !Ziizb.rhZiizb(wzgz.ilfgvh)) {&#10;                gsild mvd Viili('Rmezorw wzgz ulinzg: ilfgvh wzgz wlvh mlg vcrhg li rh mlg zm ziizb');&#10;            }&#10;&#10;            fkwzgvKiltivhh(39);&#10;&#10;            // 预处理数据&#10;            ilfgvWzgz = kivkilxvhhWzgz(wzgz.ilfgvh);&#10;            ru (!ilfgvWzgz || ilfgvWzgz.ovmtgs === 9) {&#10;                gsild mvd Viili('Ml ezorw ilfgv wzgz: Gsv wzgz rh vnkgb zugvi kivkilxvhhrmt');&#10;            }&#10;            fkwzgvKiltivhh(24);&#10;&#10;            // 计算最大重量用于比例显示&#10;            xlmhg oyhEzofvh = ilfgvWzgz.nzk(i =&gt; i.oyh).urogvi(Yllovzm);&#10;            ru (oyhEzofvh.ovmtgs === 9) {&#10;                gsild mvd Viili('Rmezorw dvrtsg wzgz: Zoo ivxliwvw oyh ezofvh ​​ziv rmezorw');&#10;            }&#10;            nzcOyh = Nzgs.nzc(...oyhEzofvh);&#10;            fkwzgvKiltivhh(14);&#10;&#10;            // 初始化FR&#10;            rmrgFR();&#10;            fkwzgvErhfzorazgrlm(8140);&#10;            fkwzgvKiltivhh(04);&#10;&#10;            // 完成加载&#10;            fkwzgvKiltivhh(899);&#10;            hvgGrnvlfg(srwvOlzwrmt, 499);&#10;&#10;        } xzgxs (viili) {&#10;            xlmhlov.viili('Zm viili lxxfiivw dsrov olzwrmt wzgz:', viili);&#10;            hsldViili(`Wzgz olzwrmt uzrovw: ${viili.nvhhztv}`);&#10;            srwvOlzwrmt();&#10;        }&#10;    }&#10;&#10;    // 数据预处理&#10;    ufmxgrlm kivkilxvhhWzgz(ilfgvh) {&#10;        ivgfim ilfgvh.nzk(ilfgv =&gt; {&#10;            // 转换路径&#10;            xlmhg kzgs = xlmevigKzgs(ilfgv.kzgs);&#10;&#10;            // 计算总距离&#10;            ovg glgzoWrhgzmxv = 9;&#10;            uli (ovg r = 8; r &lt; kzgs.ovmtgs; r++) {&#10;                glgzoWrhgzmxv += xzoxfozgvWrhgzmxv(kzgs[r - 8], kzgs[r]);&#10;            }&#10;&#10;            // 计算平均速度 (假设默认819天航程)&#10;            xlmhg wfizgrlm = ilfgv.wfizgrlm || 819;&#10;            xlmhg zetHkvvw = glgzoWrhgzmxv / wfizgrlm;&#10;&#10;            ivgfim {&#10;                ...ilfgv,&#10;                rw: tvmvizgvIlfgvRw(ilfgv),&#10;                kzgs,&#10;                glgzoWrhgzmxv,&#10;                zetHkvvw,&#10;                wfizgrlm&#10;            };&#10;        }).urogvi(ilfgv =&gt;&#10;            ilfgv.kzgs.ovmtgs &gt;= 89 &amp;&amp;&#10;            ilfgv.oyh &gt; 9 &amp;&amp;&#10;            ilfgv.grnv &gt;= 8140 &amp;&amp;&#10;            ilfgv.grnv &lt;= 8131&#10;        );&#10;    }&#10;&#10;    // 生成唯一航线RW&#10;    ufmxgrlm tvmvizgvIlfgvRw(ilfgv) {&#10;        ivgfim `${ilfgv.vcklig}-${ilfgv.rnklig_wvhg}-${ilfgv.grnv}-${ilfgv.gvz}`.ivkozxv(/\h+/t, '-');&#10;    }&#10;&#10;    // 转换路径坐标&#10;    ufmxgrlm xlmevigKzgs(kzgs) {&#10;        ivgfim kzgs.nzk(klrmg =&gt; {&#10;            xlmhg omt = kzihvUolzg(Mfnyvi(klrmg.omt).glUrcvw(3));&#10;            xlmhg ozg = kzihvUolzg(Mfnyvi(klrmg.ozg).glUrcvw(3));&#10;&#10;            ru (rhMzM(omt) || rhMzM(ozg) ||&#10;                omt &lt; -819 || omt &gt; 819 ||&#10;                ozg &lt; -09 || ozg &gt; 09) {&#10;                ivgfim mfoo;&#10;            }&#10;&#10;            ivgfim [omt, ozg];&#10;        }).urogvi(Yllovzm);&#10;    }&#10;&#10;    // 计算两点间距离 (Szevihrmv公式)&#10;    ufmxgrlm xzoxfozgvWrhgzmxv(klrmg8, klrmg7) {&#10;        xlmhg I = 3628; // 地球半径(pn)&#10;        xlmhg wOzg = (klrmg7[8] - klrmg8[8]) * Nzgs.KR / 819;&#10;        xlmhg wOlm = (klrmg7[9] - klrmg8[9]) * Nzgs.KR / 819;&#10;        xlmhg z =&#10;            Nzgs.hrm(wOzg / 7) * Nzgs.hrm(wOzg / 7) +&#10;            Nzgs.xlh(klrmg8[8] * Nzgs.KR / 819) *&#10;            Nzgs.xlh(klrmg7[8] * Nzgs.KR / 819) *&#10;            Nzgs.hrm(wOlm / 7) * Nzgs.hrm(wOlm / 7);&#10;        ivgfim I * 7 * Nzgs.zgzm7(Nzgs.hjig(z), Nzgs.hjig(8 - z));&#10;    }&#10;&#10;&#10;    ufmxgrlm xivzgvHsrkNzipvi() {&#10;        xlmhg vo = wlxfnvmg.xivzgvVovnvmg('wre');&#10;        vo.xozhhMznv = 'hsrk-nzipvi'; // 必须作为主元素&#10;&#10;        xlmhg dzevXlmgzrmvi = wlxfnvmg.xivzgvVovnvmg('wre');&#10;        dzevXlmgzrmvi.xozhhMznv = 'dzev-xlmgzrmvi';&#10;&#10;        // 正确的WLN结构&#10;        xlmhg xlmgzrmvi = wlxfnvmg.xivzgvVovnvmg('wre');&#10;        xlmgzrmvi.zkkvmwXsrow(vo);&#10;        xlmgzrmvi.zkkvmwXsrow(dzevXlmgzrmvi);&#10;        ivgfim xlmgzrmvi;&#10;    }&#10;&#10;    // 计算航行方向&#10;    ufmxgrlm xzoxfozgvYvzirmt(kive, xfiivmg) {&#10;        xlmhg b = xfiivmg[9] - kive[9];&#10;        xlmhg c = xfiivmg[8] - kive[8];&#10;        ivgfim (Nzgs.zgzm7(b, c) * 819) / Nzgs.KR + 09;&#10;    }&#10;&#10;&#10;    ufmxgrlm hgzigHsrkZmrnzgrlm(kzgs, nzipvi, rhHvovxgvw) {&#10;        xlmhg ZMRNZGRLM_WFIZGRLM = 54999; // 54秒完成全程&#10;        xlmhg XZNVIZ_LUUHVG = 9.981; // 经度偏移量&#10;        ovg zmrnzgrlmUiznvRw;&#10;        ovg hgzigGrnv = mfoo;&#10;        xlmhg zmrnzgv = (grnvhgznk) =&gt; {&#10;            ru (!hgzigGrnv) hgzigGrnv = grnvhgznk;&#10;            xlmhg vozkhvw = grnvhgznk - hgzigGrnv;&#10;            xlmhg kiltivhh = Nzgs.nrm(vozkhvw / ZMRNZGRLM_WFIZGRLM, 8);&#10;&#10;            // 使用立方缓动函数&#10;            xlmhg vzhvwKiltivhh = xfyrxVzhvRmLfg(kiltivhh);&#10;&#10;            // 获取插值后的当前位置&#10;            xlmhg xfiivmgKlh = hksvirxzoRmgviklozgv(kzgs, vzhvwKiltivhh);&#10;&#10;            // 更新标记位置&#10;            nzipvi.hvgOmtOzg(xfiivmgKlh);&#10;&#10;            // 计算动态航向（包含预测）&#10;            xlmhg yvzirmt = xzoxfozgvWbmznrxYvzirmt(kzgs, vzhvwKiltivhh);&#10;            nzipvi.hvgIlgzgrlm(yvzirmt);&#10;            // 第一视角跟随逻辑&#10;            ru (rhHvovxgvw) {&#10;                // 计算相机偏移位置&#10;                xlmhg luuhvgC = XZNVIZ_LUUHVG * Nzgs.xlh(yvzirmt * Nzgs.KR / 819);&#10;                xlmhg luuhvgB = XZNVIZ_LUUHVG * Nzgs.hrm(yvzirmt * Nzgs.KR / 819);&#10;                xlmhg zogrgfwv = 7999 + (kzgs.ovmtgs * kiltivhh * 84); // 每航点增加84米高度&#10;                nzk.qfnkGl({&#10;                    xvmgvi: [&#10;                        xfiivmgKlh[9] - luuhvgC,&#10;                        xfiivmgKlh[8] - luuhvgB&#10;                    ],&#10;                    yvzirmt: yvzirmt + 1,&#10;                    krgxs: Nzgs.nrm(kiltivhh * 39 + 74, 29), // 动态俯仰角度&#10;                    alln: 4.7,&#10;                    vhhvmgrzo: gifv,&#10;                    zogrgfwv: zogrgfwv&#10;                });&#10;                // nzk.uobGl({&#10;                //     xvmgvi: [xfiivmgKlh[9] - luuhvgC, xfiivmgKlh[8] - luuhvgB],&#10;                //     yvzirmt: yvzirmt + 1,&#10;                //     krgxs: Nzgs.nrm(kiltivhh * 39 + 74, 29),&#10;                //     alln: 4.7,&#10;                //     zogrgfwv: zogrgfwv,&#10;                //     hkvvw: 9.4,  // 运动速度&#10;                //     xfiev: 8.7    // 飞行曲线&#10;                // });&#10;&#10;            }&#10;            ru (kiltivhh &lt; 8) {&#10;                zmrnzgrlmUiznvRw = ivjfvhgZmrnzgrlmUiznv(zmrnzgv);   //保证39ukh&#10;                zxgrevZmrnzgrlmh.zww(zmrnzgrlmUiznvRw);&#10;            } vohv {&#10;                // 循环动画&#10;                hgzigGrnv = mfoo;&#10;                zmrnzgrlmUiznvRw = ivjfvhgZmrnzgrlmUiznv(zmrnzgv);&#10;                zxgrevZmrnzgrlmh.zww(zmrnzgrlmUiznvRw);&#10;            }&#10;        };&#10;        zmrnzgrlmUiznvRw = ivjfvhgZmrnzgrlmUiznv(zmrnzgv);&#10;        zxgrevZmrnzgrlmh.zww(zmrnzgrlmUiznvRw);&#10;        ivgfim zmrnzgrlmUiznvRw;&#10;    }&#10;&#10;    // 立方缓动函数&#10;    ufmxgrlm xfyrxVzhvRmLfg(g) {&#10;        g = Nzgs.nrm(Nzgs.nzc(g, 9), 8);&#10;        ivgfim g &lt; 9.4 ?&#10;            5 * g * g * g :&#10;            8 - Nzgs.kld(-7 * g + 7, 6) / 7;&#10;    }&#10;&#10;    // 动态航向计算（带预测机制）&#10;    ufmxgrlm xzoxfozgvWbmznrxYvzirmt(kzgs, kiltivhh) {&#10;        xlmhg OLLP_ZSVZW_UZXGLI = 9.92; // 2%的前视预测&#10;        xlmhg glgzoKlrmgh = kzgs.ovmtgs;&#10;&#10;        xlmhg xfiivmgRmwvc = Nzgs.uolli(kiltivhh * (glgzoKlrmgh - 8));&#10;        xlmhg ollpZsvzwRmwvc = Nzgs.nrm(&#10;            xfiivmgRmwvc + Nzgs.uolli(glgzoKlrmgh * OLLP_ZSVZW_UZXGLI),&#10;            glgzoKlrmgh - 8&#10;        );&#10;&#10;        // 处理边界情况&#10;        ru (xfiivmgRmwvc &gt;= glgzoKlrmgh - 8) ivgfim 9;&#10;        ru (ollpZsvzwRmwvc &lt;= xfiivmgRmwvc) ivgfim xzoxfozgvYvzirmt(kzgs[xfiivmgRmwvc], kzgs[xfiivmgRmwvc + 8]);&#10;&#10;        ivgfim xzoxfozgvYvzirmt(kzgs[xfiivmgRmwvc], kzgs[ollpZsvzwRmwvc]);&#10;    }&#10;&#10;    // 球面路径插值&#10;    ufmxgrlm hksvirxzoRmgviklozgv(kzgs, g) {&#10;        // 计算总距离&#10;        ovg glgzoWrhgzmxv = 9;&#10;        xlmhg hvtnvmgWrhgzmxvh = [];&#10;        uli (ovg r = 8; r &lt; kzgs.ovmtgs; r++) {&#10;            xlmhg wrhg = xzoxfozgvWrhgzmxv(kzgs[r - 8], kzgs[r]);&#10;            hvtnvmgWrhgzmxvh.kfhs(wrhg);&#10;            glgzoWrhgzmxv += wrhg;&#10;        }&#10;        // 计算目标距离&#10;        xlmhg gzitvgWrhgzmxv = g * glgzoWrhgzmxv;&#10;        ovg zxxfnfozgvw = 9;&#10;&#10;        // 找到当前所在线段&#10;        uli (ovg r = 9; r &lt; hvtnvmgWrhgzmxvh.ovmtgs; r++) {&#10;            ru (zxxfnfozgvw + hvtnvmgWrhgzmxvh[r] &gt;= gzitvgWrhgzmxv) {&#10;                xlmhg izgrl = (gzitvgWrhgzmxv - zxxfnfozgvw) / hvtnvmgWrhgzmxvh[r];&#10;                ivgfim rmgviklozgvXlliwrmzgv(kzgs[r], kzgs[r + 8], izgrl);&#10;            }&#10;            zxxfnfozgvw += hvtnvmgWrhgzmxvh[r];&#10;        }&#10;&#10;        // 返回最后一个点作为保底&#10;        ivgfim kzgs[kzgs.ovmtgs - 8];&#10;    }&#10;&#10;    // 球面坐标插值&#10;    ufmxgrlm rmgviklozgvXlliwrmzgv(hgzig, vmw, izgrl) {&#10;        xlmhg [omt8, ozg8] = hgzig.nzk(wvt =&gt; wvt * Nzgs.KR / 819);&#10;        xlmhg [omt7, ozg7] = vmw.nzk(wvt =&gt; wvt * Nzgs.KR / 819);&#10;&#10;        // 计算夹角&#10;        xlmhg w = 7 * Nzgs.zhrm(Nzgs.hjig(&#10;            Nzgs.kld(Nzgs.hrm((ozg7 - ozg8) / 7), 7) +&#10;            Nzgs.xlh(ozg8) * Nzgs.xlh(ozg7) *&#10;            Nzgs.kld(Nzgs.hrm((omt7 - omt8) / 7), 7)&#10;        ));&#10;&#10;        // 球面线性插值&#10;        xlmhg Z = Nzgs.hrm((8 - izgrl) * w) / Nzgs.hrm(w);&#10;        xlmhg Y = Nzgs.hrm(izgrl * w) / Nzgs.hrm(w);&#10;&#10;        xlmhg c = Z * Nzgs.xlh(ozg8) * Nzgs.xlh(omt8) + Y * Nzgs.xlh(ozg7) * Nzgs.xlh(omt7);&#10;        xlmhg b = Z * Nzgs.xlh(ozg8) * Nzgs.hrm(omt8) + Y * Nzgs.xlh(ozg7) * Nzgs.hrm(omt7);&#10;        xlmhg a = Z * Nzgs.hrm(ozg8) + Y * Nzgs.hrm(ozg7);&#10;&#10;        ivgfim [&#10;            ((Nzgs.zgzm7(b, c) * 819 / Nzgs.KR + 459) % 639) - 819, // 经度&#10;            Nzgs.zgzm7(a, Nzgs.hjig(c * c + b * b)) * 819 / Nzgs.KR      // 纬度&#10;        ];&#10;    }&#10;&#10;    // 缓动函数&#10;    ufmxgrlm vzhvRmLfgJfzw(g) {&#10;        ivgfim g &lt; 9.4 ? 7 * g * g : -8 + (5 - 7 * g) * g;&#10;    }&#10;&#10;&#10;    // 更新可视化&#10;    ufmxgrlm fkwzgvErhfzorazgrlm(bvzi) {&#10;        // 清除旧元素&#10;        zxgrevZmrnzgrlmh.uliVzxs(rw =&gt; xzmxvoZmrnzgrlmUiznv(rw));&#10;        zxgrevZmrnzgrlmh.xovzi();&#10;        xfiivmgNzipvih.uliVzxs(nzipvi =&gt; nzipvi.ivnlev());&#10;        xfiivmgNzipvih = [];&#10;&#10;        // 过滤当前年份的数据&#10;        xlmhg ezorwWzgz = ilfgvWzgz.urogvi(rgvn =&gt; rgvn.grnv == bvzi);&#10;&#10;        ru (ezorwWzgz.ovmtgs === 9) {&#10;            hsldViili(`没有找到 ${bvzi} 年的航线数据`);&#10;            ivgfim;&#10;        }&#10;&#10;        // 更新航线选择器&#10;        wlxfnvmg.tvgVovnvmgYbRw('ilfgvHvovxgli').zwwVevmgOrhgvmvi('xszmtv', v =&gt; {&#10;            hvovxgvwIlfgvRw = v.gzitvg.ezofv || mfoo;&#10;            xlmhg xfiivmgBvzi = kzihvRmg(wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv);&#10;&#10;            // 查找当前选中航线&#10;            xlmhg hvovxgvwIlfgv = ilfgvWzgz.urmw(ilfgv =&gt;&#10;                ilfgv.rw === hvovxgvwIlfgvRw &amp;&amp;&#10;                ilfgv.grnv === xfiivmgBvzi&#10;            );&#10;            ru (hvovxgvwIlfgv) {&#10;                hsldIlfgvRmul(hvovxgvwIlfgv);&#10;                // 自动聚焦到该航线&#10;                uobGlIlfgv(hvovxgvwIlfgv);&#10;            } vohv {&#10;                xovziIlfgvRmul();&#10;            }&#10;            fkwzgvErhfzorazgrlm(xfiivmgBvzi);&#10;        });&#10;&#10;        // 新增自动展示逻辑&#10;        ru (hvovxgvwIlfgvRw) {&#10;            xlmhg hvovxgvwIlfgv = ezorwWzgz.urmw(i =&gt; i.rw === hvovxgvwIlfgvRw);&#10;            ru (hvovxgvwIlfgv) {&#10;                hsldIlfgvRmul(hvovxgvwIlfgv);&#10;                // 高亮选中航线&#10;                nzk.hvgUvzgfivHgzgv(&#10;                    {hlfixv: 'ilfgvh', rw: hvovxgvwIlfgvRw},&#10;                    {hvovxgvw: gifv}&#10;                );&#10;            }&#10;        }&#10;&#10;        ufmxgrlm uobGlIlfgv(ilfgv) {&#10;            xlmhg ylfmwh = mvd nzkylcto.OmtOzgYlfmwh();&#10;            ilfgv.kzgs.uliVzxs(klrmg =&gt; ylfmwh.vcgvmw(klrmg));&#10;&#10;            nzk.urgYlfmwh(ylfmwh, {&#10;                kzwwrmt: 19,&#10;                wfizgrlm: 8199,&#10;                vhhvmgrzo: gifv,&#10;                krgxs: 54,&#10;                yvzirmt: 69&#10;            });&#10;        }&#10;&#10;        ufmxgrlm xovziIlfgvRmul() {&#10;            wlxfnvmg.tvgVovnvmgYbRw('ilfgv-rmul').rmmviSGNO =&#10;                '&lt;k&gt;请选择一条航线查看详细信息&lt;/k&gt;';&#10;            hvovxgvwIlfgvRw = mfoo;&#10;        }&#10;&#10;        xlmhg hvovxgli = wlxfnvmg.tvgVovnvmgYbRw('ilfgvHvovxgli');&#10;        hvovxgli.rmmviSGNO = '&lt;lkgrlm ezofv=&quot;&quot;&gt;-- 请选择 --&lt;/lkgrlm&gt;';&#10;&#10;        ezorwWzgz.uliVzxs((rgvn) =&gt; {&#10;            xlmhg lkgrlm = wlxfnvmg.xivzgvVovnvmg('lkgrlm');&#10;            lkgrlm.ezofv = rgvn.rw;&#10;            lkgrlm.gvcg = `${rgvn.vcklig} → ${rgvn.rnklig_wvhg} (${rgvn.gvz})`;&#10;            hvovxgli.zkkvmwXsrow(lkgrlm);&#10;        });&#10;&#10;        // 如果之前选择了某条航线，尝试保持选择&#10;        ru (hvovxgvwIlfgvRw) {&#10;            xlmhg hvovxgvwLkgrlm = hvovxgli.jfvibHvovxgli(`lkgrlm[ezofv=&quot;${hvovxgvwIlfgvRw}&quot;]`);&#10;            ru (hvovxgvwLkgrlm) {&#10;                hvovxgvwLkgrlm.hvovxgvw = gifv;&#10;            } vohv {&#10;                hvovxgvwIlfgvRw = mfoo;&#10;            }&#10;        }&#10;&#10;        // 创建航线图层&#10;        ru (nzk.tvgOzbvi('ilfgvh')) nzk.ivnlevOzbvi('ilfgvh');&#10;        ru (nzk.tvgHlfixv('ilfgvh')) nzk.ivnlevHlfixv('ilfgvh');&#10;&#10;        nzk.zwwHlfixv('ilfgvh', {&#10;            gbkv: 'tvlqhlm',&#10;            wzgz: {&#10;                gbkv: 'UvzgfivXloovxgrlm',&#10;                uvzgfivh: ezorwWzgz.nzk(rgvn =&gt; ({&#10;                    gbkv: 'Uvzgfiv',&#10;                    kilkvigrvh: {&#10;                        rw: rgvn.rw,&#10;                        vcklig: rgvn.vcklig,&#10;                        rnklig_wvhg: rgvn.rnklig_wvhg,&#10;                        xloli: rgvn.gvz === 'Yozxp gvz' ? '#1Y5486' : '#771Y77',&#10;                        drwgs: 9.4 + (rgvn.oyh / nzcOyh) * 6,&#10;                        lkzxrgb: 9.2&#10;                    },&#10;                    tvlnvgib: {&#10;                        gbkv: 'OrmvHgirmt',&#10;                        xlliwrmzgvh: rgvn.kzgs&#10;                    }&#10;                }))&#10;            }&#10;        });&#10;&#10;        nzk.zwwOzbvi({&#10;            rw: 'ilfgvh',&#10;            gbkv: 'ormv',&#10;            hlfixv: 'ilfgvh',&#10;            kzrmg: {&#10;                'ormv-xloli': ['tvg', 'xloli'],&#10;                'ormv-drwgs': ['tvg', 'drwgs'],&#10;                'ormv-lkzxrgb': ['tvg', 'lkzxrgb']&#10;            }&#10;        });&#10;&#10;&#10;        // 启动所有航线动画&#10;        ezorwWzgz.uliVzxs((rgvn) =&gt; {&#10;            ru (rgvn.kzgs.ovmtgs &lt; 7) ivgfim;&#10;            xlmhg nzipvi = mvd nzkylcto.Nzipvi({&#10;                vovnvmg: xivzgvHsrkNzipvi(),&#10;                ilgzgrlmZortmnvmg: 'nzk'&#10;            }).hvgOmtOzg(rgvn.kzgs[9]).zwwGl(nzk);&#10;&#10;            xfiivmgNzipvih.kfhs(nzipvi);&#10;&#10;            xlmhg zmrnzgrlmRw = hgzigHsrkZmrnzgrlm(&#10;                rgvn.kzgs,&#10;                nzipvi,&#10;                rgvn.rw === hvovxgvwIlfgvRw,&#10;                rgvn.zetHkvvw&#10;            );&#10;        });&#10;&#10;        // 添加航线交互&#10;        nzk.lm('xorxp', 'ilfgvh', (v) =&gt; {&#10;            xlmhg uvzgfiv = v.uvzgfivh[9];&#10;            xlmhg ilfgvRw = uvzgfiv.kilkvigrvh.rw;&#10;            xlmhg ilfgv = ezorwWzgz.urmw(i =&gt; i.rw === ilfgvRw);&#10;&#10;            ru (ilfgv) {&#10;                hsldIlfgvRmul(ilfgv);&#10;                // 选中该航线&#10;                wlxfnvmg.tvgVovnvmgYbRw('ilfgvHvovxgli').ezofv = ilfgvRw;&#10;                hvovxgvwIlfgvRw = ilfgvRw;&#10;                fkwzgvErhfzorazgrlm(bvzi);&#10;            }&#10;        });&#10;&#10;&#10;        // // 创建路径点图层&#10;        // xlmhg klrmgUvzgfivh = ezorwWzgz.uozgNzk(ilfgv =&gt;&#10;        //     ilfgv.kzgs.nzk((xlliw, rmwvc) =&gt; ({&#10;        //         gbkv: 'Uvzgfiv',&#10;        //         tvlnvgib: {&#10;        //             gbkv: 'Klrmg',&#10;        //             xlliwrmzgvh: xlliw&#10;        //         },&#10;        //         kilkvigrvh: {&#10;        //             ilfgvRw: ilfgv.rw,&#10;        //             gbkv: rmwvc === 9 ? 'hgzig' :&#10;        //                 rmwvc === ilfgv.kzgs.ovmtgs - 8 ? 'vmw' : 'dzbklrmg',&#10;        //             hvjfvmxv: rmwvc + 8,&#10;        //             glgzoKlrmgh: ilfgv.kzgs.ovmtgs&#10;        //         }&#10;        //     }))&#10;        // );&#10;        // // 添加点数据源&#10;        // ru (nzk.tvgHlfixv('ilfgv-klrmgh')) nzk.ivnlevHlfixv('ilfgv-klrmgh');&#10;        // nzk.zwwHlfixv('ilfgv-klrmgh', {&#10;        //     gbkv: 'tvlqhlm',&#10;        //     wzgz: {&#10;        //         gbkv: 'UvzgfivXloovxgrlm',&#10;        //         uvzgfivh: klrmgUvzgfivh&#10;        //     }&#10;        // });&#10;        // // 添加点图层&#10;        // ru (!nzk.tvgOzbvi('ilfgv-klrmgh')) {&#10;        //     nzk.zwwOzbvi({&#10;        //         rw: 'ilfgv-klrmgh',&#10;        //         gbkv: 'xrixov',&#10;        //         hlfixv: 'ilfgv-klrmgh',&#10;        //         kzrmg: {&#10;        //             'xrixov-xloli': [&#10;        //                 'nzgxs', ['tvg', 'gbkv'],&#10;        //                 'hgzig', '#5XZU49',&#10;        //                 'vmw', '#U55663',&#10;        //                 '#7803U6'&#10;        //             ],&#10;        //             'xrixov-izwrfh': [&#10;        //                 'xzhv',&#10;        //                 ['==', ['tvg', 'gbkv'], 'dzbklrmg'], 5,&#10;        //                 3&#10;        //             ],&#10;        //             'xrixov-hgilpv-drwgs': 7,&#10;        //             'xrixov-hgilpv-xloli': 'dsrgv'&#10;        //         }&#10;        //     });&#10;        // }&#10;        //&#10;        //&#10;        // // 添加交互功能&#10;        // nzk.lm('xorxp', 'ilfgv-klrmgh', (v) =&gt; {&#10;        //     xlmhg uvzgfivh = nzk.jfvibIvmwvivwUvzgfivh(v.klrmg, {&#10;        //         ozbvih: ['ilfgv-klrmgh']&#10;        //     });&#10;        //&#10;        //     ru (uvzgfivh.ovmtgs &gt; 9) {&#10;        //         xlmhg klrmg = uvzgfivh[9].kilkvigrvh;&#10;        //         mvd nzkylcto.Klkfk()&#10;        //             .hvgOmtOzg(v.omtOzg)&#10;        //             .hvgSGNO(`&#10;        //             &lt;wre xozhh=&quot;klrmg-rmul&quot;&gt;&#10;        //                 &lt;s5&gt;航点详情&lt;/s5&gt;&#10;        //                 &lt;k&gt;类型：${tvgKlrmgGbkvXM(klrmg.gbkv)}&lt;/k&gt;&#10;        //                 &lt;k&gt;序号：${klrmg.hvjfvmxv}/${klrmg.glgzoKlrmgh}&lt;/k&gt;&#10;        //                 &lt;k&gt;经度：${v.omtOzg.omt.glUrcvw(5)}°&lt;/k&gt;&#10;        //                 &lt;k&gt;纬度：${v.omtOzg.ozg.glUrcvw(5)}°&lt;/k&gt;&#10;        //                 &lt;k&gt;所属航线：${tvgIlfgvMznv(klrmg.ilfgvRw)}&lt;/k&gt;&#10;        //             &lt;/wre&gt;&#10;        //         `)&#10;        //             .zwwGl(nzk);&#10;        //     }&#10;        // });&#10;&#10;        nzk.lm('nlfhvvmgvi', 'ilfgvh', () =&gt; {&#10;            nzk.tvgXzmezh().hgbov.xfihli = 'klrmgvi';&#10;        });&#10;&#10;        nzk.lm('nlfhvovzev', 'ilfgvh', () =&gt; {&#10;            nzk.tvgXzmezh().hgbov.xfihli = '';&#10;        });&#10;    }&#10;&#10;    // 显示航线信息&#10;    ufmxgrlm hsldIlfgvRmul(ilfgv) {&#10;        xlmhg rmulKzmvo = wlxfnvmg.tvgVovnvmgYbRw('ilfgv-rmul');&#10;&#10;        rmulKzmvo.rmmviSGNO = `&#10;            &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;Ilfgv:&lt;/hkzm&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;${ilfgv.vcklig} → ${ilfgv.rnklig_wvhg}&lt;/hkzm&gt;&#10;            &lt;/wre&gt;&#10;            &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;Gvz Gbkv:&lt;/hkzm&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;${ilfgv.gvz}&lt;/hkzm&gt;&#10;            &lt;/wre&gt;&#10;            &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;Bvzih:&lt;/hkzm&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;${ilfgv.grnv}&lt;/hkzm&gt;&#10;            &lt;/wre&gt;&#10;            &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;Gizmhklig elofnv:&lt;/hkzm&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;${ulinzgMfnyvi(ilfgv.oyh)} oyh&lt;/hkzm&gt;&#10;            &lt;/wre&gt;&#10;            &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;Glgzo wrhgzmxv:&lt;/hkzm&gt;&#10;                &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;${ilfgv.glgzoWrhgzmxv.glUrcvw(7)} pn&lt;/hkzm&gt;&#10;            &lt;/wre&gt;&#10;            // &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;            //     &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;平均速度:&lt;/hkzm&gt;&#10;            //     &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;${ilfgv.zetHkvvw.glUrcvw(7)} pn/天&lt;/hkzm&gt;&#10;            // &lt;/wre&gt;&#10;            // &lt;wre xozhh=&quot;hgzgh-rgvn&quot;&gt;&#10;            //     &lt;hkzm xozhh=&quot;hgzgh-ozyvo&quot;&gt;预计航程:&lt;/hkzm&gt;&#10;            //     &lt;hkzm xozhh=&quot;hgzgh-ezofv&quot;&gt;约 ${Nzgs.ilfmw(ilfgv.wfizgrlm)} 天&lt;/hkzm&gt;&#10;            // &lt;/wre&gt;&#10;            &lt;wre xozhh=&quot;kiltivhh-xlmgzrmvi&quot;&gt;&#10;                &lt;wre xozhh=&quot;kiltivhh-yzi&quot; hgbov=&quot;drwgs: ${(ilfgv.oyh / nzcOyh) * 899}%&quot;&gt;&lt;/wre&gt;&#10;            &lt;/wre&gt;&#10;            &lt;hnzoo&gt;Gizmhklig elofnv hsziv: ${((ilfgv.oyh / nzcOyh) * 899).glUrcvw(8)}%&lt;/hnzoo&gt;&#10;        `;&#10;    }&#10;&#10;    // 初始化FR控件&#10;    ufmxgrlm rmrgFR() {&#10;        // 年份选择&#10;        wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').zwwVevmgOrhgvmvi('rmkfg', _.gsilggov(v =&gt; {&#10;            xlmhg bvzi = kzihvRmg(v.gzitvg.ezofv);&#10;            wlxfnvmg.tvgVovnvmgYbRw('bvziEzofv').gvcgXlmgvmg = bvzi;&#10;            hvovxgvwIlfgvRw = mfoo;&#10;            fkwzgvErhfzorazgrlm(bvzi);&#10;        }, 699));&#10;&#10;        // 航线选择&#10;        wlxfnvmg.tvgVovnvmgYbRw('ilfgvHvovxgli').zwwVevmgOrhgvmvi('xszmtv', v =&gt; {&#10;            hvovxgvwIlfgvRw = v.gzitvg.ezofv || mfoo;&#10;            fkwzgvErhfzorazgrlm(wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv);&#10;        });&#10;&#10;        // 播放/暂停按钮&#10;        wlxfnvmg.tvgVovnvmgYbRw('kozbYfgglm').zwwVevmgOrhgvmvi('xorxp', () =&gt; {&#10;            rhKozbrmt = !rhKozbrmt;&#10;            wlxfnvmg.tvgVovnvmgYbRw('kozbYfgglm').gvcgXlmgvmg = rhKozbrmt ? '暂停动画' : '播放动画';&#10;&#10;            ru (rhKozbrmt) {&#10;                ovg bvzi = kzihvRmg(wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv);&#10;                kozbRmgviezo = hvgRmgviezo(() =&gt; {&#10;                    bvzi++;&#10;                    ru (bvzi &gt; 8131) bvzi = 8140;&#10;&#10;                    wlxfnvmg.tvgVovnvmgYbRw('bvziHorwvi').ezofv = bvzi;&#10;                    wlxfnvmg.tvgVovnvmgYbRw('bvziEzofv').gvcgXlmgvmg = bvzi;&#10;                    fkwzgvErhfzorazgrlm(bvzi);&#10;                }, 54899);&#10;            } vohv {&#10;                xovziRmgviezo(kozbRmgviezo);&#10;            }&#10;        });&#10;&#10;        // 重置按钮&#10;        wlxfnvmg.tvgVovnvmgYbRw('ivhvgYfgglm').zwwVevmgOrhgvmvi('xorxp', () =&gt; {&#10;            nzk.uobGl({&#10;                xvmgvi: [879, 69],&#10;                alln: 5,&#10;                krgxs: 74,&#10;                yvzirmt: 9&#10;            });&#10;        });&#10;    }&#10;&#10;    // 显示加载状态&#10;    ufmxgrlm hsldOlzwrmt(nvhhztv = '加载中...') {&#10;        wlxfnvmg.tvgVovnvmgYbRw('olzwrmt-leviozb').hgbov.wrhkozb = 'uovc';&#10;        wlxfnvmg.jfvibHvovxgli('#olzwrmt-leviozb wre').gvcgXlmgvmg = nvhhztv;&#10;    }&#10;&#10;    // 更新加载进度&#10;    ufmxgrlm fkwzgvKiltivhh(kvixvmg) {&#10;        wlxfnvmg.tvgVovnvmgYbRw('olzwrmt-kiltivhh').hgbov.drwgs = `${kvixvmg}%`;&#10;    }&#10;&#10;    // 隐藏加载状态&#10;    ufmxgrlm srwvOlzwrmt() {&#10;        wlxfnvmg.tvgVovnvmgYbRw('olzwrmt-leviozb').hgbov.wrhkozb = 'mlmv';&#10;    }&#10;&#10;    // 显示错误信息&#10;    ufmxgrlm hsldViili(nvhhztv) {&#10;        wlxfnvmg.tvgVovnvmgYbRw('viili-nvhhztv').gvcgXlmgvmg = nvhhztv;&#10;        hvgGrnvlfg(() =&gt; {&#10;            wlxfnvmg.tvgVovnvmgYbRw('viili-nvhhztv').gvcgXlmgvmg = '';&#10;        }, 4999);&#10;    }&#10;&#10;    // 数字格式化&#10;    ufmxgrlm ulinzgMfnyvi(mfn) {&#10;        ivgfim mfn.glHgirmt().ivkozxv(/\Y(?=(\w{6})+(?!\w))/t, &quot;,&quot;);&#10;    }&#10;&#10;&#10;    // 初始化应用&#10;    rmrgNzk();&#10;&lt;/hxirkg&gt;&#10;&lt;/ylwb&gt;&#10;&lt;/sgno&gt;" />
                      <option name="end_line" value="1046" />
                      <option name="filename" value="index.html" />
                      <option name="language" value="HTML" />
                      <option name="range">
                        <Range>
                          <option name="end">
                            <Position>
                              <option name="character" value="6" />
                              <option name="line" value="1046" />
                            </Position>
                          </option>
                          <option name="start">
                            <Position />
                          </option>
                        </Range>
                      </option>
                      <option name="type" value="editor" />
                      <option name="url" value="file:///D:/pycharmWorkspace/PythonProject/templates/index.html" />
                    </CodeReferencesBean>
                  </list>
                </option>
                <option name="command" value="" />
                <option name="conversationId" value="019614ba273071e3813ae8f5538d8f26" />
                <option name="historyDocumentMap">
                  <map>
                    <entry key="file:///D:/pycharmWorkspace/PythonProject/templates/index.html" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;zh-CN&quot;&gt;&#10;&lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;    &lt;title&gt;Visualization of tea trade routes&lt;/title&gt;&#10;    &lt;script src=&quot;https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js&quot;&gt;&lt;/script&gt;&#10;    &lt;link href=&quot;https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot;&gt;&#10;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;&#10;    &lt;style&gt;&#10;        body {&#10;            margin: 0;&#10;            padding: 0;&#10;            font-family: 'Arial', sans-serif;&#10;            overflow: hidden;&#10;        }&#10;&#10;        #map {&#10;            position: absolute;&#10;            top: 0;&#10;            bottom: 0;&#10;            width: 100%;&#10;        }&#10;&#10;        #control-panel {&#10;            position: absolute;&#10;            top: 20px;&#10;            left: 20px;&#10;            z-index: 1000;&#10;            background: rgba(255, 255, 255, 0.9);&#10;            padding: 15px;&#10;            border-radius: 8px;&#10;            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);&#10;            width: 280px;&#10;        }&#10;&#10;        #info-panel {&#10;            position: absolute;&#10;            bottom: 20px;&#10;            left: 20px;&#10;            z-index: 1000;&#10;            background: rgba(255, 255, 255, 0.9);&#10;            padding: 15px;&#10;            border-radius: 8px;&#10;            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);&#10;            width: 280px;&#10;            max-height: 200px;&#10;            overflow-y: auto;&#10;        }&#10;&#10;        #loading-overlay {&#10;            position: absolute;&#10;            top: 0;&#10;            left: 0;&#10;            right: 0;&#10;            bottom: 0;&#10;            background: rgba(0, 0, 0, 0.7);&#10;            display: flex;&#10;            justify-content: center;&#10;            align-items: center;&#10;            z-index: 2000;&#10;            color: white;&#10;            font-size: 1.5em;&#10;            flex-direction: column;&#10;        }&#10;&#10;        .control-group {&#10;            margin-bottom: 15px;&#10;        }&#10;&#10;        .control-group label {&#10;            display: block;&#10;            margin-bottom: 5px;&#10;            font-weight: bold;&#10;        }&#10;&#10;        select, input[type=&quot;range&quot;] {&#10;            width: 100%;&#10;        }&#10;&#10;        button {&#10;            background: #4CAF50;&#10;            color: white;&#10;            border: none;&#10;            padding: 8px 12px;&#10;            border-radius: 4px;&#10;            cursor: pointer;&#10;            width: 100%;&#10;            margin-top: 5px;&#10;        }&#10;&#10;        button:hover {&#10;            background: #45a049;&#10;        }&#10;&#10;        /* 船舶标记 */&#10;        .ship-marker {&#10;            background-image: url('/static/小船-蓝.svg');&#10;            background-size: contain;&#10;            background-repeat: no-repeat;&#10;            transform: translateY(42%); /* 下沉到水面位置 */&#10;            width: 32px !important;&#10;            height: 32px !important;&#10;            transition: all 0.3s; /* 添加平滑过渡 */&#10;            position: relative;&#10;            z-index: 10;&#10;            display: block;&#10;            transition: transform 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94),&#10;            filter 0.3s ease;&#10;            filter: drop-shadow(2px 3px 6px rgba(0, 0, 0, 0.5)) brightness(1.05);&#10;            transform-origin: center 80%;&#10;            animation: float 2.8s ease-in-out infinite;&#10;        }&#10;&#10;        /* 浮动动画 */&#10;        @keyframes float {&#10;            0%, 100% {&#10;                transform: translateY(0) rotate(-3deg) scale(1);&#10;            }&#10;            50% {&#10;                transform: translateY(-12px) rotate(5deg) scale(1.05);&#10;            }&#10;        }&#10;&#10;        /* 波浪动画 */&#10;        .wave-container {&#10;            position: absolute;&#10;            width: 150%;&#10;            height: 30px;&#10;            bottom: -22px;&#10;            left: -25%;&#10;            opacity: 0.8;&#10;            pointer-events: none;&#10;            mix-blend-mode: screen;&#10;        }&#10;&#10;        .wave {&#10;            background: radial-gradient(circle at 50% 50%,&#10;            rgba(33, 150, 243, 0.8) 20%,&#10;            rgba(33, 150, 243, 0.3) 40%,&#10;            rgba(33, 150, 243, 0) 70%&#10;            );&#10;            animation: wave 1.8s cubic-bezier(0.4, 0, 0.2, 1) infinite,&#10;            ripple 2.4s infinite;&#10;        }&#10;&#10;        @keyframes ripple {&#10;            0% {&#10;                opacity: 0;&#10;                transform: scale(0.1);&#10;            }&#10;            50% {&#10;                opacity: 0.4;&#10;            }&#10;            100% {&#10;                opacity: 0;&#10;                transform: scale(2.5);&#10;            }&#10;        }&#10;&#10;        .stats-item {&#10;            margin-bottom: 8px;&#10;            font-size: 0.9em;&#10;        }&#10;&#10;        .stats-label {&#10;            font-weight: bold;&#10;            color: #333;&#10;        }&#10;&#10;        .mapboxgl-marker {&#10;            z-index: 100 !important;&#10;        }&#10;&#10;        .stats-value {&#10;            color: #2c3e50;&#10;        }&#10;&#10;        #error-message {&#10;            color: #e74c3c;&#10;            margin-top: 10px;&#10;            font-size: 0.9em;&#10;        }&#10;&#10;        .progress-container {&#10;            width: 100%;&#10;            background-color: #f1f1f1;&#10;            border-radius: 5px;&#10;            margin-top: 10px;&#10;        }&#10;&#10;        .progress-bar {&#10;            height: 10px;&#10;            border-radius: 5px;&#10;            background-color: #4CAF50;&#10;            width: 0%;&#10;            transition: width 0.3s;&#10;        }&#10;&#10;            /* 路径点标记样式 */&#10;    /*.waypoint-marker {*/&#10;    /*    width: 8px;*/&#10;    /*    height: 8px;*/&#10;    /*    border-radius: 50%;*/&#10;    /*    border: 2px solid white;*/&#10;    /*    box-shadow: 0 2px 4px rgba(0,0,0,0.3);*/&#10;    /*    transition: all 0.3s ease;*/&#10;    /*}*/&#10;    /*.start-point { background: #4CAF50; }  !* 绿色 *!*/&#10;    /*.end-point { background: #F44336; }    !* 红色 *!*/&#10;    /*.waypoint { background: #2196F3; }     !* 蓝色 *!*/&#10;&#10;    /*.waypoint-marker.selected {*/&#10;    /*    transform: scale(1.8);*/&#10;    /*    z-index: 300 !important;*/&#10;    /*    box-shadow: 0 0 8px rgba(255,235,59,0.8);*/&#10;    /*}*/&#10;&#10;        .mapboxgl-marker.selected {&#10;            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));&#10;            transform: scale(1.15);&#10;            z-index: 200 !important;&#10;        }&#10;&#10;        .selected-route {&#10;            line-color: #ffd700 !important;&#10;            line-width: 3 !important;&#10;        }&#10;    &lt;/style&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&#10;&#10;&lt;div id=&quot;control-panel&quot;&gt;&#10;    &lt;h2&gt;Visualization of tea trade routes&lt;/h2&gt;&#10;    &lt;div class=&quot;control-group&quot;&gt;&#10;        &lt;label for=&quot;yearSlider&quot;&gt;Year: &lt;span id=&quot;yearValue&quot;&gt;1859&lt;/span&gt;&lt;/label&gt;&#10;        &lt;input type=&quot;range&quot; id=&quot;yearSlider&quot; min=&quot;1859&quot; max=&quot;1868&quot; value=&quot;1859&quot; step=&quot;1&quot;&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;control-group&quot;&gt;&#10;        &lt;label for=&quot;routeSelector&quot;&gt;Select route:&lt;/label&gt;&#10;        &lt;select id=&quot;routeSelector&quot;&gt;&#10;            &lt;option value=&quot;&quot;&gt;-- Please select --&lt;/option&gt;&#10;        &lt;/select&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div class=&quot;control-group&quot;&gt;&#10;        &lt;button id=&quot;playButton&quot;&gt;Play Animation&lt;/button&gt;&#10;        &lt;button id=&quot;resetButton&quot;&gt;Reset View&lt;/button&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;div id=&quot;error-message&quot;&gt;&lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;div id=&quot;info-panel&quot;&gt;&#10;    &lt;h3&gt;Route Information&lt;/h3&gt;&#10;    &lt;div id=&quot;route-info&quot;&gt;&#10;        &lt;p&gt;Please select a route to view detailed information&lt;/p&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;div id=&quot;loading-overlay&quot;&gt;&#10;    &lt;div&gt;Loading data...&lt;/div&gt;&#10;    &lt;div class=&quot;progress-container&quot;&gt;&#10;        &lt;div class=&quot;progress-bar&quot; id=&quot;loading-progress&quot;&gt;&lt;/div&gt;&#10;    &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;script&gt;&#10;    // import {FBXLoader} from 'three/examples/jsm/loaders/FBXLoader';&#10;    //&#10;    // const loader = new FBXLoader();&#10;    // loader.load('animated_ship.fbx', (fbx) =&gt; {&#10;    //     // 自动处理骨骼动画&#10;    //     const mixer = new THREE.AnimationMixer(fbx);&#10;    //     const action = mixer.clipAction(fbx.animations[0]);&#10;    //     action.play();&#10;    //&#10;    //     // 每帧更新动画&#10;    //     function animate() {&#10;    //         mixer.update(clock.getDelta());&#10;    //         requestAnimationFrame(animate);&#10;    //     }&#10;    //&#10;    //     animate();&#10;    // });&#10;    // 全局变量&#10;    let map;&#10;    let currentMarkers = [];&#10;    let activeAnimations = new Set();&#10;    let selectedRouteId = null;&#10;    let routeData = [];&#10;    let maxLbs = 0;&#10;    let isPlaying = false;&#10;    let playInterval;&#10;&#10;    // 初始化地图&#10;    function initMap() {&#10;        if (!mapboxgl.supported()) {&#10;            showError('Your browser does not support WebGL and cannot display 3D maps.');&#10;            return;&#10;        }&#10;        mapboxgl.accessToken = 'pk.eyJ1IjoiMTMxNDAwIiwiYSI6ImNtOTAxMnIxazBpOGsya3Nhdmw2MDgzdWEifQ.JXO93YTQKXwts51IMaPQ5A';&#10;        map = new mapboxgl.Map({&#10;            container: 'map',&#10;            style: 'mapbox://styles/mapbox/satellite-streets-v12',&#10;            center: [120, 30],&#10;            zoom: 4,&#10;            pitch: 25,&#10;            maxPitch: 70,&#10;            maxZoom: 12,&#10;            minZoom: 3,&#10;            interactive: true,&#10;            trackResize: true,&#10;            antialias: true,  // 开启抗锯齿&#10;            attributionControl: false, // 隐藏默认属性控件&#10;            renderWorldCopies: false,   // 优化性能&#10;            bearing: -10, // 初始方位角&#10;            optimizeForTerrain: true,&#10;            maxTileCacheSize: 500,&#10;            localIdeographFontFamily: ['Noto Sans Regular']&#10;        });&#10;        // 添加自定义属性控件&#10;        map.addControl(new mapboxgl.AttributionControl({&#10;            compact: true,&#10;            customAttribution: '&lt;a href=&quot;#copyright&quot;&gt;Historical data sources&lt;/a&gt;'&#10;        }));&#10;        map.on('style.load', () =&gt; {&#10;            // 添加地形源&#10;            map.addSource('mapbox-dem', {&#10;                type: 'raster-dem',&#10;                url: 'mapbox://mapbox.mapbox-terrain-dem-v1',&#10;                tileSize: 512,&#10;                maxzoom: 14&#10;            });&#10;&#10;            // 设置地形&#10;            map.setTerrain({&#10;                source: 'mapbox-dem',&#10;                exaggeration: 1.2&#10;            });&#10;&#10;            map.addLayer({&#10;                id: '3d-buildings',&#10;                source: 'composite',&#10;                'source-layer': 'building',&#10;                filter: ['==', 'extrude', 'true'],&#10;                type: 'fill-extrusion',&#10;                minzoom: 13,&#10;                paint: {&#10;                    'fill-extrusion-color': '#ddd',&#10;                    'fill-extrusion-height': [&#10;                        &quot;interpolate&quot;, [&quot;linear&quot;],&#10;                        [&quot;zoom&quot;], 15, 0, 15.05, [&quot;get&quot;, &quot;height&quot;]&#10;                    ],&#10;                    'fill-extrusion-base': [&#10;                        &quot;interpolate&quot;, [&quot;linear&quot;],&#10;                        [&quot;zoom&quot;], 15, 0, 15.05, [&quot;get&quot;, &quot;min_height&quot;]&#10;                    ],&#10;                    'fill-extrusion-opacity': 0.6&#10;                }&#10;            });&#10;&#10;&#10;            // 添加天空效果&#10;            map.addLayer({&#10;                id: 'sky',&#10;                type: 'sky',&#10;                paint: {&#10;                    'sky-type': 'atmosphere',&#10;                    'sky-atmosphere-sun': [0.0, 90.0],&#10;                    'sky-atmosphere-sun-intensity': 15&#10;                }&#10;            });&#10;        });&#10;        map.on('load', onMapLoad);&#10;    }&#10;&#10;    // 地图加载完成回调&#10;    async function onMapLoad() {&#10;        showLoading('Loading route data...');&#10;&#10;        try {&#10;            // 显示加载状态&#10;            showLoading();&#10;            updateProgress(0);&#10;&#10;            // 调用API获取数据&#10;            const response = await fetch('/api/data');&#10;            updateProgress(20);&#10;&#10;            // 检查响应状态&#10;            if (!response.ok) {&#10;                throw new Error(`Network Error: ${response.status}`);&#10;            }&#10;&#10;            updateProgress(30);&#10;&#10;            // 解析JSON数据&#10;            const data = await response.json();&#10;            console.log('API响应数据:', data);&#10;            updateProgress(50);&#10;&#10;            // 验证数据格式&#10;            if (!data?.routes || !Array.isArray(data.routes)) {&#10;                throw new Error('Invalid data format: routes data does not exist or is not an array');&#10;            }&#10;&#10;            updateProgress(60);&#10;&#10;            // 预处理数据&#10;            routeData = preprocessData(data.routes);&#10;            if (!routeData || routeData.length === 0) {&#10;                throw new Error('No valid route data: The data is empty after preprocessing');&#10;            }&#10;            updateProgress(75);&#10;&#10;            // 计算最大重量用于比例显示&#10;            const lbsValues = routeData.map(r =&gt; r.lbs).filter(Boolean);&#10;            if (lbsValues.length === 0) {&#10;                throw new Error('Invalid weight data: All recorded lbs values ​​are invalid');&#10;            }&#10;            maxLbs = Math.max(...lbsValues);&#10;            updateProgress(85);&#10;&#10;            // 初始化UI&#10;            initUI();&#10;            updateVisualization(1859);&#10;            updateProgress(95);&#10;&#10;            // 完成加载&#10;            updateProgress(100);&#10;            setTimeout(hideLoading, 500);&#10;&#10;        } catch (error) {&#10;            console.error('An error occurred while loading data:', error);&#10;            showError(`Data loading failed: ${error.message}`);&#10;            hideLoading();&#10;        }&#10;    }&#10;&#10;    // 数据预处理&#10;    function preprocessData(routes) {&#10;        return routes.map(route =&gt; {&#10;            // 转换路径&#10;            const path = convertPath(route.path);&#10;&#10;            // 计算总距离&#10;            let totalDistance = 0;&#10;            for (let i = 1; i &lt; path.length; i++) {&#10;                totalDistance += calculateDistance(path[i - 1], path[i]);&#10;            }&#10;&#10;            // 计算平均速度 (假设默认180天航程)&#10;            const duration = route.duration || 180;&#10;            const avgSpeed = totalDistance / duration;&#10;&#10;            return {&#10;                ...route,&#10;                id: generateRouteId(route),&#10;                path,&#10;                totalDistance,&#10;                avgSpeed,&#10;                duration&#10;            };&#10;        }).filter(route =&gt;&#10;            route.path.length &gt;= 10 &amp;&amp;&#10;            route.lbs &gt; 0 &amp;&amp;&#10;            route.time &gt;= 1859 &amp;&amp;&#10;            route.time &lt;= 1868&#10;        );&#10;    }&#10;&#10;    // 生成唯一航线ID&#10;    function generateRouteId(route) {&#10;        return `${route.export}-${route.import_dest}-${route.time}-${route.tea}`.replace(/\s+/g, '-');&#10;    }&#10;&#10;    // 转换路径坐标&#10;    function convertPath(path) {&#10;        return path.map(point =&gt; {&#10;            const lng = parseFloat(Number(point.lng).toFixed(6));&#10;            const lat = parseFloat(Number(point.lat).toFixed(6));&#10;&#10;            if (isNaN(lng) || isNaN(lat) ||&#10;                lng &lt; -180 || lng &gt; 180 ||&#10;                lat &lt; -90 || lat &gt; 90) {&#10;                return null;&#10;            }&#10;&#10;            return [lng, lat];&#10;        }).filter(Boolean);&#10;    }&#10;&#10;    // 计算两点间距离 (Haversine公式)&#10;    function calculateDistance(point1, point2) {&#10;        const R = 6371; // 地球半径(km)&#10;        const dLat = (point2[1] - point1[1]) * Math.PI / 180;&#10;        const dLon = (point2[0] - point1[0]) * Math.PI / 180;&#10;        const a =&#10;            Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;            Math.cos(point1[1] * Math.PI / 180) *&#10;            Math.cos(point2[1] * Math.PI / 180) *&#10;            Math.sin(dLon / 2) * Math.sin(dLon / 2);&#10;        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));&#10;    }&#10;&#10;&#10;    function createShipMarker() {&#10;        const el = document.createElement('div');&#10;        el.className = 'ship-marker'; // 必须作为主元素&#10;&#10;        const waveContainer = document.createElement('div');&#10;        waveContainer.className = 'wave-container';&#10;&#10;        // 正确的DOM结构&#10;        const container = document.createElement('div');&#10;        container.appendChild(el);&#10;        container.appendChild(waveContainer);&#10;        return container;&#10;    }&#10;&#10;    // 计算航行方向&#10;    function calculateBearing(prev, current) {&#10;        const y = current[0] - prev[0];&#10;        const x = current[1] - prev[1];&#10;        return (Math.atan2(y, x) * 180) / Math.PI + 90;&#10;    }&#10;&#10;&#10;    function startShipAnimation(path, marker, isSelected) {&#10;        const ANIMATION_DURATION = 45000; // 45秒完成全程&#10;        const CAMERA_OFFSET = 0.018; // 经度偏移量&#10;        let animationFrameId;&#10;        let startTime = null;&#10;        const animate = (timestamp) =&gt; {&#10;            if (!startTime) startTime = timestamp;&#10;            const elapsed = timestamp - startTime;&#10;            const progress = Math.min(elapsed / ANIMATION_DURATION, 1);&#10;&#10;            // 使用立方缓动函数&#10;            const easedProgress = cubicEaseInOut(progress);&#10;&#10;            // 获取插值后的当前位置&#10;            const currentPos = sphericalInterpolate(path, easedProgress);&#10;&#10;            // 更新标记位置&#10;            marker.setLngLat(currentPos);&#10;&#10;            // 计算动态航向（包含预测）&#10;            const bearing = calculateDynamicBearing(path, easedProgress);&#10;            marker.setRotation(bearing);&#10;            // 第一视角跟随逻辑&#10;            if (isSelected) {&#10;                // 计算相机偏移位置&#10;                const offsetX = CAMERA_OFFSET * Math.cos(bearing * Math.PI / 180);&#10;                const offsetY = CAMERA_OFFSET * Math.sin(bearing * Math.PI / 180);&#10;                const altitude = 2000 + (path.length * progress * 15); // 每航点增加15米高度&#10;                map.jumpTo({&#10;                    center: [&#10;                        currentPos[0] - offsetX,&#10;                        currentPos[1] - offsetY&#10;                    ],&#10;                    bearing: bearing + 8,&#10;                    pitch: Math.min(progress * 60 + 25, 70), // 动态俯仰角度&#10;                    zoom: 5.2,&#10;                    essential: true,&#10;                    altitude: altitude&#10;                });&#10;                // map.flyTo({&#10;                //     center: [currentPos[0] - offsetX, currentPos[1] - offsetY],&#10;                //     bearing: bearing + 8,&#10;                //     pitch: Math.min(progress * 60 + 25, 70),&#10;                //     zoom: 5.2,&#10;                //     altitude: altitude,&#10;                //     speed: 0.5,  // 运动速度&#10;                //     curve: 1.2    // 飞行曲线&#10;                // });&#10;&#10;            }&#10;            if (progress &lt; 1) {&#10;                animationFrameId = requestAnimationFrame(animate);   //保证60fps&#10;                activeAnimations.add(animationFrameId);&#10;            } else {&#10;                // 循环动画&#10;                startTime = null;&#10;                animationFrameId = requestAnimationFrame(animate);&#10;                activeAnimations.add(animationFrameId);&#10;            }&#10;        };&#10;        animationFrameId = requestAnimationFrame(animate);&#10;        activeAnimations.add(animationFrameId);&#10;        return animationFrameId;&#10;    }&#10;&#10;    // 立方缓动函数&#10;    function cubicEaseInOut(t) {&#10;        t = Math.min(Math.max(t, 0), 1);&#10;        return t &lt; 0.5 ?&#10;            4 * t * t * t :&#10;            1 - Math.pow(-2 * t + 2, 3) / 2;&#10;    }&#10;&#10;    // 动态航向计算（带预测机制）&#10;    function calculateDynamicBearing(path, progress) {&#10;        const LOOK_AHEAD_FACTOR = 0.07; // 7%的前视预测&#10;        const totalPoints = path.length;&#10;&#10;        const currentIndex = Math.floor(progress * (totalPoints - 1));&#10;        const lookAheadIndex = Math.min(&#10;            currentIndex + Math.floor(totalPoints * LOOK_AHEAD_FACTOR),&#10;            totalPoints - 1&#10;        );&#10;&#10;        // 处理边界情况&#10;        if (currentIndex &gt;= totalPoints - 1) return 0;&#10;        if (lookAheadIndex &lt;= currentIndex) return calculateBearing(path[currentIndex], path[currentIndex + 1]);&#10;&#10;        return calculateBearing(path[currentIndex], path[lookAheadIndex]);&#10;    }&#10;&#10;    // 球面路径插值&#10;    function sphericalInterpolate(path, t) {&#10;        // 计算总距离&#10;        let totalDistance = 0;&#10;        const segmentDistances = [];&#10;        for (let i = 1; i &lt; path.length; i++) {&#10;            const dist = calculateDistance(path[i - 1], path[i]);&#10;            segmentDistances.push(dist);&#10;            totalDistance += dist;&#10;        }&#10;        // 计算目标距离&#10;        const targetDistance = t * totalDistance;&#10;        let accumulated = 0;&#10;&#10;        // 找到当前所在线段&#10;        for (let i = 0; i &lt; segmentDistances.length; i++) {&#10;            if (accumulated + segmentDistances[i] &gt;= targetDistance) {&#10;                const ratio = (targetDistance - accumulated) / segmentDistances[i];&#10;                return interpolateCoordinate(path[i], path[i + 1], ratio);&#10;            }&#10;            accumulated += segmentDistances[i];&#10;        }&#10;&#10;        // 返回最后一个点作为保底&#10;        return path[path.length - 1];&#10;    }&#10;&#10;    // 球面坐标插值&#10;    function interpolateCoordinate(start, end, ratio) {&#10;        const [lng1, lat1] = start.map(deg =&gt; deg * Math.PI / 180);&#10;        const [lng2, lat2] = end.map(deg =&gt; deg * Math.PI / 180);&#10;&#10;        // 计算夹角&#10;        const d = 2 * Math.asin(Math.sqrt(&#10;            Math.pow(Math.sin((lat2 - lat1) / 2), 2) +&#10;            Math.cos(lat1) * Math.cos(lat2) *&#10;            Math.pow(Math.sin((lng2 - lng1) / 2), 2)&#10;        ));&#10;&#10;        // 球面线性插值&#10;        const A = Math.sin((1 - ratio) * d) / Math.sin(d);&#10;        const B = Math.sin(ratio * d) / Math.sin(d);&#10;&#10;        const x = A * Math.cos(lat1) * Math.cos(lng1) + B * Math.cos(lat2) * Math.cos(lng2);&#10;        const y = A * Math.cos(lat1) * Math.sin(lng1) + B * Math.cos(lat2) * Math.sin(lng2);&#10;        const z = A * Math.sin(lat1) + B * Math.sin(lat2);&#10;&#10;        return [&#10;            ((Math.atan2(y, x) * 180 / Math.PI + 540) % 360) - 180, // 经度&#10;            Math.atan2(z, Math.sqrt(x * x + y * y)) * 180 / Math.PI      // 纬度&#10;        ];&#10;    }&#10;&#10;    // 缓动函数&#10;    function easeInOutQuad(t) {&#10;        return t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;&#10;    }&#10;&#10;&#10;    // 更新可视化&#10;    function updateVisualization(year) {&#10;        // 清除旧元素&#10;        activeAnimations.forEach(id =&gt; cancelAnimationFrame(id));&#10;        activeAnimations.clear();&#10;        currentMarkers.forEach(marker =&gt; marker.remove());&#10;        currentMarkers = [];&#10;&#10;        // 过滤当前年份的数据&#10;        const validData = routeData.filter(item =&gt; item.time == year);&#10;&#10;        if (validData.length === 0) {&#10;            showError(`没有找到 ${year} 年的航线数据`);&#10;            return;&#10;        }&#10;&#10;        // 更新航线选择器&#10;        document.getElementById('routeSelector').addEventListener('change', e =&gt; {&#10;            selectedRouteId = e.target.value || null;&#10;            const currentYear = parseInt(document.getElementById('yearSlider').value);&#10;&#10;            // 查找当前选中航线&#10;            const selectedRoute = routeData.find(route =&gt;&#10;                route.id === selectedRouteId &amp;&amp;&#10;                route.time === currentYear&#10;            );&#10;            if (selectedRoute) {&#10;                showRouteInfo(selectedRoute);&#10;                // 自动聚焦到该航线&#10;                flyToRoute(selectedRoute);&#10;            } else {&#10;                clearRouteInfo();&#10;            }&#10;            updateVisualization(currentYear);&#10;        });&#10;&#10;        // 新增自动展示逻辑&#10;        if (selectedRouteId) {&#10;            const selectedRoute = validData.find(r =&gt; r.id === selectedRouteId);&#10;            if (selectedRoute) {&#10;                showRouteInfo(selectedRoute);&#10;                // 高亮选中航线&#10;                map.setFeatureState(&#10;                    {source: 'routes', id: selectedRouteId},&#10;                    {selected: true}&#10;                );&#10;            }&#10;        }&#10;&#10;        function flyToRoute(route) {&#10;            const bounds = new mapboxgl.LngLatBounds();&#10;            route.path.forEach(point =&gt; bounds.extend(point));&#10;&#10;            map.fitBounds(bounds, {&#10;                padding: 80,&#10;                duration: 1800,&#10;                essential: true,&#10;                pitch: 45,&#10;                bearing: 30&#10;            });&#10;        }&#10;&#10;        function clearRouteInfo() {&#10;            document.getElementById('route-info').innerHTML =&#10;                '&lt;p&gt;请选择一条航线查看详细信息&lt;/p&gt;';&#10;            selectedRouteId = null;&#10;        }&#10;&#10;        const selector = document.getElementById('routeSelector');&#10;        selector.innerHTML = '&lt;option value=&quot;&quot;&gt;-- 请选择 --&lt;/option&gt;';&#10;&#10;        validData.forEach((item) =&gt; {&#10;            const option = document.createElement('option');&#10;            option.value = item.id;&#10;            option.text = `${item.export} → ${item.import_dest} (${item.tea})`;&#10;            selector.appendChild(option);&#10;        });&#10;&#10;        // 如果之前选择了某条航线，尝试保持选择&#10;        if (selectedRouteId) {&#10;            const selectedOption = selector.querySelector(`option[value=&quot;${selectedRouteId}&quot;]`);&#10;            if (selectedOption) {&#10;                selectedOption.selected = true;&#10;            } else {&#10;                selectedRouteId = null;&#10;            }&#10;        }&#10;&#10;        // 创建航线图层&#10;        if (map.getLayer('routes')) map.removeLayer('routes');&#10;        if (map.getSource('routes')) map.removeSource('routes');&#10;&#10;        map.addSource('routes', {&#10;            type: 'geojson',&#10;            data: {&#10;                type: 'FeatureCollection',&#10;                features: validData.map(item =&gt; ({&#10;                    type: 'Feature',&#10;                    properties: {&#10;                        id: item.id,&#10;                        export: item.export,&#10;                        import_dest: item.import_dest,&#10;                        color: item.tea === 'Black tea' ? '#8B4513' : '#228B22',&#10;                        width: 0.5 + (item.lbs / maxLbs) * 3,&#10;                        opacity: 0.7&#10;                    },&#10;                    geometry: {&#10;                        type: 'LineString',&#10;                        coordinates: item.path&#10;                    }&#10;                }))&#10;            }&#10;        });&#10;&#10;        map.addLayer({&#10;            id: 'routes',&#10;            type: 'line',&#10;            source: 'routes',&#10;            paint: {&#10;                'line-color': ['get', 'color'],&#10;                'line-width': ['get', 'width'],&#10;                'line-opacity': ['get', 'opacity']&#10;            }&#10;        });&#10;&#10;&#10;        // 启动所有航线动画&#10;        validData.forEach((item) =&gt; {&#10;            if (item.path.length &lt; 2) return;&#10;            const marker = new mapboxgl.Marker({&#10;                element: createShipMarker(),&#10;                rotationAlignment: 'map'&#10;            }).setLngLat(item.path[0]).addTo(map);&#10;&#10;            currentMarkers.push(marker);&#10;&#10;            const animationId = startShipAnimation(&#10;                item.path,&#10;                marker,&#10;                item.id === selectedRouteId,&#10;                item.avgSpeed&#10;            );&#10;        });&#10;&#10;        // 添加航线交互&#10;        map.on('click', 'routes', (e) =&gt; {&#10;            const feature = e.features[0];&#10;            const routeId = feature.properties.id;&#10;            const route = validData.find(r =&gt; r.id === routeId);&#10;&#10;            if (route) {&#10;                showRouteInfo(route);&#10;                // 选中该航线&#10;                document.getElementById('routeSelector').value = routeId;&#10;                selectedRouteId = routeId;&#10;                updateVisualization(year);&#10;            }&#10;        });&#10;&#10;&#10;        // // 创建路径点图层&#10;        // const pointFeatures = validData.flatMap(route =&gt;&#10;        //     route.path.map((coord, index) =&gt; ({&#10;        //         type: 'Feature',&#10;        //         geometry: {&#10;        //             type: 'Point',&#10;        //             coordinates: coord&#10;        //         },&#10;        //         properties: {&#10;        //             routeId: route.id,&#10;        //             type: index === 0 ? 'start' :&#10;        //                 index === route.path.length - 1 ? 'end' : 'waypoint',&#10;        //             sequence: index + 1,&#10;        //             totalPoints: route.path.length&#10;        //         }&#10;        //     }))&#10;        // );&#10;        // // 添加点数据源&#10;        // if (map.getSource('route-points')) map.removeSource('route-points');&#10;        // map.addSource('route-points', {&#10;        //     type: 'geojson',&#10;        //     data: {&#10;        //         type: 'FeatureCollection',&#10;        //         features: pointFeatures&#10;        //     }&#10;        // });&#10;        // // 添加点图层&#10;        // if (!map.getLayer('route-points')) {&#10;        //     map.addLayer({&#10;        //         id: 'route-points',&#10;        //         type: 'circle',&#10;        //         source: 'route-points',&#10;        //         paint: {&#10;        //             'circle-color': [&#10;        //                 'match', ['get', 'type'],&#10;        //                 'start', '#4CAF50',&#10;        //                 'end', '#F44336',&#10;        //                 '#2196F3'&#10;        //             ],&#10;        //             'circle-radius': [&#10;        //                 'case',&#10;        //                 ['==', ['get', 'type'], 'waypoint'], 4,&#10;        //                 6&#10;        //             ],&#10;        //             'circle-stroke-width': 2,&#10;        //             'circle-stroke-color': 'white'&#10;        //         }&#10;        //     });&#10;        // }&#10;        //&#10;        //&#10;        // // 添加交互功能&#10;        // map.on('click', 'route-points', (e) =&gt; {&#10;        //     const features = map.queryRenderedFeatures(e.point, {&#10;        //         layers: ['route-points']&#10;        //     });&#10;        //&#10;        //     if (features.length &gt; 0) {&#10;        //         const point = features[0].properties;&#10;        //         new mapboxgl.Popup()&#10;        //             .setLngLat(e.lngLat)&#10;        //             .setHTML(`&#10;        //             &lt;div class=&quot;point-info&quot;&gt;&#10;        //                 &lt;h4&gt;航点详情&lt;/h4&gt;&#10;        //                 &lt;p&gt;类型：${getPointTypeCN(point.type)}&lt;/p&gt;&#10;        //                 &lt;p&gt;序号：${point.sequence}/${point.totalPoints}&lt;/p&gt;&#10;        //                 &lt;p&gt;经度：${e.lngLat.lng.toFixed(4)}°&lt;/p&gt;&#10;        //                 &lt;p&gt;纬度：${e.lngLat.lat.toFixed(4)}°&lt;/p&gt;&#10;        //                 &lt;p&gt;所属航线：${getRouteName(point.routeId)}&lt;/p&gt;&#10;        //             &lt;/div&gt;&#10;        //         `)&#10;        //             .addTo(map);&#10;        //     }&#10;        // });&#10;&#10;        map.on('mouseenter', 'routes', () =&gt; {&#10;            map.getCanvas().style.cursor = 'pointer';&#10;        });&#10;&#10;        map.on('mouseleave', 'routes', () =&gt; {&#10;            map.getCanvas().style.cursor = '';&#10;        });&#10;    }&#10;&#10;    // 显示航线信息&#10;    function showRouteInfo(route) {&#10;        const infoPanel = document.getElementById('route-info');&#10;&#10;        infoPanel.innerHTML = `&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;Route:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.export} → ${route.import_dest}&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;Tea Type:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.tea}&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;Years:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.time}&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;Transport volume:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${formatNumber(route.lbs)} lbs&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            &lt;div class=&quot;stats-item&quot;&gt;&#10;                &lt;span class=&quot;stats-label&quot;&gt;Total distance:&lt;/span&gt;&#10;                &lt;span class=&quot;stats-value&quot;&gt;${route.totalDistance.toFixed(2)} km&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            // &lt;div class=&quot;stats-item&quot;&gt;&#10;            //     &lt;span class=&quot;stats-label&quot;&gt;平均速度:&lt;/span&gt;&#10;            //     &lt;span class=&quot;stats-value&quot;&gt;${route.avgSpeed.toFixed(2)} km/天&lt;/span&gt;&#10;            // &lt;/div&gt;&#10;            // &lt;div class=&quot;stats-item&quot;&gt;&#10;            //     &lt;span class=&quot;stats-label&quot;&gt;预计航程:&lt;/span&gt;&#10;            //     &lt;span class=&quot;stats-value&quot;&gt;约 ${Math.round(route.duration)} 天&lt;/span&gt;&#10;            // &lt;/div&gt;&#10;            &lt;div class=&quot;progress-container&quot;&gt;&#10;                &lt;div class=&quot;progress-bar&quot; style=&quot;width: ${(route.lbs / maxLbs) * 100}%&quot;&gt;&lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;small&gt;Transport volume share: ${((route.lbs / maxLbs) * 100).toFixed(1)}%&lt;/small&gt;&#10;        `;&#10;    }&#10;&#10;    // 初始化UI控件&#10;    function initUI() {&#10;        // 年份选择&#10;        document.getElementById('yearSlider').addEventListener('input', _.throttle(e =&gt; {&#10;            const year = parseInt(e.target.value);&#10;            document.getElementById('yearValue').textContent = year;&#10;            selectedRouteId = null;&#10;            updateVisualization(year);&#10;        }, 300));&#10;&#10;        // 航线选择&#10;        document.getElementById('routeSelector').addEventListener('change', e =&gt; {&#10;            selectedRouteId = e.target.value || null;&#10;            updateVisualization(document.getElementById('yearSlider').value);&#10;        });&#10;&#10;        // 播放/暂停按钮&#10;        document.getElementById('playButton').addEventListener('click', () =&gt; {&#10;            isPlaying = !isPlaying;&#10;            document.getElementById('playButton').textContent = isPlaying ? '暂停动画' : '播放动画';&#10;&#10;            if (isPlaying) {&#10;                let year = parseInt(document.getElementById('yearSlider').value);&#10;                playInterval = setInterval(() =&gt; {&#10;                    year++;&#10;                    if (year &gt; 1868) year = 1859;&#10;&#10;                    document.getElementById('yearSlider').value = year;&#10;                    document.getElementById('yearValue').textContent = year;&#10;                    updateVisualization(year);&#10;                }, 45100);&#10;            } else {&#10;                clearInterval(playInterval);&#10;            }&#10;        });&#10;&#10;        // 重置按钮&#10;        document.getElementById('resetButton').addEventListener('click', () =&gt; {&#10;            map.flyTo({&#10;                center: [120, 30],&#10;                zoom: 4,&#10;                pitch: 25,&#10;                bearing: 0&#10;            });&#10;        });&#10;    }&#10;&#10;    // 显示加载状态&#10;    function showLoading(message = '加载中...') {&#10;        document.getElementById('loading-overlay').style.display = 'flex';&#10;        document.querySelector('#loading-overlay div').textContent = message;&#10;    }&#10;&#10;    // 更新加载进度&#10;    function updateProgress(percent) {&#10;        document.getElementById('loading-progress').style.width = `${percent}%`;&#10;    }&#10;&#10;    // 隐藏加载状态&#10;    function hideLoading() {&#10;        document.getElementById('loading-overlay').style.display = 'none';&#10;    }&#10;&#10;    // 显示错误信息&#10;    function showError(message) {&#10;        document.getElementById('error-message').textContent = message;&#10;        setTimeout(() =&gt; {&#10;            document.getElementById('error-message').textContent = '';&#10;        }, 5000);&#10;    }&#10;&#10;    // 数字格式化&#10;    function formatNumber(num) {&#10;        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);&#10;    }&#10;&#10;&#10;    // 初始化应用&#10;    initMap();&#10;&lt;/script&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;" />
                  </map>
                </option>
                <option name="messageId" value="01961970c89872f0b4f73432d4a81769" />
                <option name="question" value="nzcOyh是所有数据的nzcOyh还是当前年份的" />
                <option name="rating" value="UNRATED" />
                <option name="referenceBeans">
                  <list />
                </option>
                <option name="status" value="SUCCESS" />
                <option name="variables">
                  <list />
                </option>
              </Turn>
            </list>
          </option>
          <option name="updateTime" value="1744183587911" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1744009157916" />
          <option name="id" value="01960f0bdd1c71df9c54d00342fb93ce" />
          <option name="title" value="新对话 2025年4月07日 14:59:17" />
          <option name="updateTime" value="1744009157916" />
        </Conversation>
        <Conversation>
          <option name="createTime" value="1743933826206" />
          <option name="id" value="01960a8e649e7b78a8454982d272d1c3" />
          <option name="title" value="新对话 2025年4月06日 18:03:46" />
          <option name="updateTime" value="1743933826206" />
        </Conversation>
      </list>
    </option>
  </component>
</project>